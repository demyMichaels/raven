<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase Changes & Brownian Motion</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0a12;
            --bg-secondary: #12121f;
            --liquid-color: #0066cc;
            --vapor-color: #ff6b35;
            --molecule-liquid: #4dabf7;
            --molecule-vapor: #ffa94d;
            --molecule-solid: #00d4aa;
            --tracer-color: #f72585;
            --tracer-glow: rgba(247, 37, 133, 0.6);
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
            --accent: #7c3aed;
            --solid-color: #00d4aa;
            --heat-gradient-1: #1a1a2e;
            --heat-gradient-2: #16213e;
            --heat-gradient-3: #0f3460;
        }

        .dark {
            --bg-primary: #0a0a12;
            --bg-secondary: #12121f;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 20px;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
            border-bottom: 1px solid rgba(124, 58, 237, 0.3);
        }

        h1 {
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            font-weight: 700;
            background: linear-gradient(135deg, #00d4aa 0%, #4dabf7 33%, #f72585 66%, #ffa94d 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            letter-spacing: -0.5px;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            padding: 20px;
        }

        @media (min-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr 360px;
            }
        }

        .left-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .simulation-container {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(124, 58, 237, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            border-radius: 12px;
            overflow: hidden;
            background: linear-gradient(180deg, #0d0d1a 0%, #1a1a2e 100%);
        }

        #simulationCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .pressure-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pressure-arrows {
            display: flex;
            gap: 2px;
        }

        .pressure-arrow {
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 8px solid #888;
            animation: pressDown 1s ease-in-out infinite;
        }

        .pressure-arrow:nth-child(2) { animation-delay: 0.2s; }
        .pressure-arrow:nth-child(3) { animation-delay: 0.4s; }

        @keyframes pressDown {
            0%, 100% { transform: translateY(0); opacity: 0.5; }
            50% { transform: translateY(3px); opacity: 1; }
        }

        .controls-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            border: 1px solid rgba(124, 58, 237, 0.2);
        }

        .control-section {
            margin-bottom: 24px;
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .control-label span {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .control-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--vapor-color);
            background: rgba(255, 107, 53, 0.1);
            padding: 4px 10px;
            border-radius: 6px;
        }

        .temperature-slider {
            width: 100%;
            height: 12px;
            -webkit-appearance: none;
            appearance: none;
            border-radius: 6px;
            background: linear-gradient(90deg, #2196F3 0%, #FFC107 50%, #FF5722 100%);
            outline: none;
            cursor: pointer;
        }

        .temperature-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            border: 3px solid var(--vapor-color);
            transition: transform 0.2s;
        }

        .temperature-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .phase-indicator {
            display: flex;
            gap: 10px;
            margin-top: 16px;
        }

        .phase-badge {
            flex: 1;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .phase-badge.solid {
            background: rgba(0, 212, 170, 0.2);
            border: 1px solid rgba(0, 212, 170, 0.4);
            color: var(--solid-color);
        }

        .phase-badge.liquid {
            background: rgba(77, 171, 247, 0.2);
            border: 1px solid rgba(77, 171, 247, 0.4);
            color: var(--molecule-liquid);
        }

        .phase-badge.vapor {
            background: rgba(255, 169, 77, 0.2);
            border: 1px solid rgba(255, 169, 77, 0.4);
            color: var(--molecule-vapor);
        }

        .phase-badge.active {
            transform: scale(1.05);
            box-shadow: 0 0 20px currentColor;
        }

        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-dot.solid-mol { background: var(--molecule-solid); box-shadow: 0 0 8px var(--molecule-solid); }
        .legend-dot.liquid-mol { background: var(--molecule-liquid); box-shadow: 0 0 8px var(--molecule-liquid); }
        .legend-dot.vapor-mol { background: var(--molecule-vapor); box-shadow: 0 0 8px var(--molecule-vapor); }
        .legend-dot.tracer { background: var(--tracer-color); box-shadow: 0 0 8px var(--tracer-color); }
        .legend-dot.trail { background: linear-gradient(90deg, var(--tracer-color), transparent); border-radius: 2px; width: 20px; height: 4px; }

        .info-cards {
            display: grid;
            gap: 12px;
            margin-top: 20px;
        }

        .info-card {
            background: rgba(124, 58, 237, 0.1);
            border: 1px solid rgba(124, 58, 237, 0.2);
            border-radius: 10px;
            padding: 14px;
            transition: all 0.3s;
        }

        .info-card.active {
            background: rgba(124, 58, 237, 0.2);
            border-color: var(--accent);
        }

        .info-card h3 {
            font-size: 0.85rem;
            color: var(--accent);
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .info-card p {
            font-size: 0.78rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .toggle-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .toggle-btn {
            flex: 1;
            min-width: 100px;
            padding: 10px 16px;
            border: 1px solid rgba(124, 58, 237, 0.3);
            background: transparent;
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.85rem;
            transition: all 0.3s;
        }

        .toggle-btn:hover {
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .toggle-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .gravity-note {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.1) 0%, rgba(247, 37, 133, 0.1) 100%);
            border: 1px solid rgba(255, 107, 53, 0.3);
            border-radius: 10px;
            padding: 14px;
            margin-top: 16px;
        }

        .gravity-note h4 {
            font-size: 0.8rem;
            color: var(--vapor-color);
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .gravity-note p {
            font-size: 0.75rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .stats-row {
            display: flex;
            gap: 10px;
            margin-top: 16px;
            align-items: stretch;
        }

        .stat-box {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 8px 14px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-box .value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            font-weight: 600;
            color: var(--molecule-solid);
        }

        .stat-box .label {
            font-size: 0.65rem;
            color: var(--text-secondary);
            line-height: 1.2;
        }

        .stat-box.liquid .value {
            color: var(--molecule-liquid);
        }

        .stat-box.vapor .value {
            color: var(--molecule-vapor);
        }

        /* Heating Curve Chart Styles */
        .chart-container {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(124, 58, 237, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .chart-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            min-height: 250px;
        }

        #heatingCurveCanvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 8px;
        }

        .chart-tooltip {
            position: absolute;
            background: rgba(18, 18, 31, 0.95);
            border: 1px solid var(--accent);
            border-radius: 10px;
            padding: 12px 16px;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            max-width: 280px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            cursor: pointer;
        }

        .chart-tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .tooltip-formula {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            padding: 8px 12px;
            background: rgba(124, 58, 237, 0.2);
            border-radius: 6px;
            margin-bottom: 8px;
            color: var(--accent);
        }

        .tooltip-desc {
            font-size: 0.78rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .tooltip-hint {
            font-size: 0.68rem;
            color: var(--text-secondary);
            margin-top: 8px;
            opacity: 0.7;
            font-style: italic;
        }

        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(124, 58, 237, 0.2);
        }

        .chart-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .chart-legend-color {
            width: 16px;
            height: 4px;
            border-radius: 2px;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        @media (max-width: 600px) {
            .container { padding: 10px; }
            header { padding: 20px 15px; }
            .main-content { padding: 10px; }
            .simulation-container, .controls-panel, .chart-container { padding: 15px; }
            .legend { grid-template-columns: 1fr; }
            .stats-row { flex-direction: column; }
            .chart-legend { flex-direction: column; gap: 8px; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Phase Changes & Brownian Motion</h1>
        <p class="subtitle">H‚ÇÇO Molecular Dance: Solid ‚Üí Liquid ‚Üí Vapor</p>
    </header>

    <div class="main-content container">
        <div class="left-column">
            <div class="simulation-container">
                <div class="canvas-wrapper">
                    <canvas id="simulationCanvas"></canvas>
                    <div class="pressure-indicator">
                        <div class="pressure-arrows">
                            <div class="pressure-arrow"></div>
                            <div class="pressure-arrow"></div>
                            <div class="pressure-arrow"></div>
                        </div>
                        <span>Atmospheric Pressure (1 atm)</span>
                    </div>
                </div>

                <div class="stats-row">
                    <div class="stat-box" id="statPhase">
                        <div class="value" id="currentPhase">SOLID</div>
                        <div class="label">Current<br>Phase</div>
                    </div>
                    <div class="stat-box liquid" id="statSpeed">
                        <div class="value" id="avgSpeed">0</div>
                        <div class="label">Avg Molecule<br>Speed (m/s)</div>
                    </div>
                    <div class="stat-box vapor" id="statCount">
                        <div class="value" id="moleculeCount">0</div>
                        <div class="label">Active<br>Molecules</div>
                    </div>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-dot solid-mol"></div>
                        <span>Ice (H‚ÇÇO Solid)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot liquid-mol"></div>
                        <span>Water (H‚ÇÇO Liquid)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot vapor-mol"></div>
                        <span>Steam (H‚ÇÇO Vapor)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot tracer"></div>
                        <span>Brownian Particle</span>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-title">üìà Heating Curve of Water (H‚ÇÇO at 1 atm)</div>
                <div class="chart-wrapper">
                    <canvas id="heatingCurveCanvas"></canvas>
                    <div class="chart-tooltip" id="chartTooltip">
                        <div class="tooltip-title"></div>
                        <div class="tooltip-formula"></div>
                        <div class="tooltip-desc"></div>
                        <div class="tooltip-hint">Tap to dismiss</div>
                    </div>
                </div>
                <div class="chart-legend">
                    <div class="chart-legend-item">
                        <div class="chart-legend-color" style="background: var(--solid-color);"></div>
                        <span>Ice</span>
                    </div>
                    <div class="chart-legend-item">
                        <div class="chart-legend-color" style="background: var(--accent);"></div>
                        <span>Melting</span>
                    </div>
                    <div class="chart-legend-item">
                        <div class="chart-legend-color" style="background: var(--molecule-liquid);"></div>
                        <span>Water</span>
                    </div>
                    <div class="chart-legend-item">
                        <div class="chart-legend-color" style="background: var(--vapor-color);"></div>
                        <span>Boiling</span>
                    </div>
                    <div class="chart-legend-item">
                        <div class="chart-legend-color" style="background: var(--molecule-vapor);"></div>
                        <span>Steam</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls-panel">
            <div class="control-section">
                <div class="control-label">
                    <span>üå°Ô∏è Temperature</span>
                    <span class="control-value" id="tempValue">-20¬∞C</span>
                </div>
                <input type="range" class="temperature-slider" id="tempSlider" min="-20" max="150" value="-20">

                <div class="phase-indicator">
                    <div class="phase-badge solid active" id="phaseSolid">SOLID</div>
                    <div class="phase-badge liquid" id="phaseLiquid">LIQUID</div>
                    <div class="phase-badge vapor" id="phaseVapor">VAPOR</div>
                </div>
            </div>

            <div class="control-section">
                <div class="control-label">
                    <span>üéØ Show Brownian Motion</span>
                </div>
                <div class="toggle-group">
                    <button class="toggle-btn active" id="btnTrailOn">Trails ON</button>
                    <button class="toggle-btn" id="btnTrailOff">Trails OFF</button>
                </div>
            </div>

            <div class="info-cards">
                <div class="info-card active" id="infoSolid">
                    <h3>üßä Solid Phase (Ice)</h3>
                    <p>Water molecules are locked in a <strong>crystalline lattice</strong>, vibrating in place but not moving freely. The Brownian particle shows minimal jiggling from molecular vibrations.</p>
                </div>
                <div class="info-card" id="infoLiquid">
                    <h3>üíß Liquid Phase (Water)</h3>
                    <p>H‚ÇÇO molecules move freely while staying close together. The Brownian particle shows classic <strong>random motion</strong> from countless molecular collisions.</p>
                </div>
                <div class="info-card" id="infoVapor">
                    <h3>‚òÅÔ∏è Vapor Phase (Steam)</h3>
                    <p>Water molecules move <strong>rapidly in all directions</strong> with high kinetic energy. Steam rises and expands as molecules escape the liquid surface.</p>
                </div>
                <div class="info-card" id="infoMelting">
                    <h3>üîÑ Melting Transition (0¬∞C)</h3>
                    <p>At the melting point, ice crystals break down as hydrogen bonds loosen. Temperature stays constant while energy goes into breaking bonds.</p>
                </div>
                <div class="info-card" id="infoBoiling">
                    <h3>üí® Boiling Transition (100¬∞C)</h3>
                    <p>At the boiling point, liquid water rapidly converts to vapor. Bubbles form and steam is released as molecules gain enough energy to escape.</p>
                </div>
            </div>

            <div class="gravity-note">
                <h4>‚ö†Ô∏è Phase Transition Physics</h4>
                <p>At 0¬∞C ice melts into water. At 100¬∞C water boils and releases steam. The temperature plateaus during phase changes as energy goes into breaking molecular bonds rather than increasing kinetic energy.</p>
            </div>
        </div>
    </div>

    <footer>
        Interactive simulation of H‚ÇÇO molecular kinetics and phase transitions
    </footer>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // ========== PHYSICAL CONSTANTS FOR WATER ==========
        const WATER_PROPERTIES = {
            c_ice: 2.09,
            c_water: 4.18,
            c_steam: 2.01,
            L_fusion: 334,
            L_vaporization: 2260,
            T_melting: 0,
            T_boiling: 100,
            T_min: -20,
            T_max: 150,
            mass: 1
        };

        function calculateHeatingCurveSegments() {
            const props = WATER_PROPERTIES;
            const m = props.mass;

            const Q1 = m * props.c_ice * (props.T_melting - props.T_min);
            const Q2 = m * props.L_fusion;
            const Q3 = m * props.c_water * (props.T_boiling - props.T_melting);
            const Q4 = m * props.L_vaporization;
            const Q5 = m * props.c_steam * (props.T_max - props.T_boiling);

            const Q_end_ice = Q1;
            const Q_end_melting = Q_end_ice + Q2;
            const Q_end_water = Q_end_melting + Q3;
            const Q_end_boiling = Q_end_water + Q4;
            const Q_total = Q_end_boiling + Q5;

            return [
                {
                    name: 'Heating Ice',
                    startQ: 0,
                    endQ: Q_end_ice,
                    startT: props.T_min,
                    endT: props.T_melting,
                    color: '#00d4aa',
                    formula: 'Q = mcŒîT',
                    formulaExpanded: 'Q = m √ó c_ice √ó ŒîT',
                    description: 'Ice absorbs heat and temperature rises. H‚ÇÇO molecules vibrate faster in their fixed crystalline positions. c_ice = ' + props.c_ice + ' J/g¬∞C',
                    type: 'sensible',
                    specificHeat: props.c_ice
                },
                {
                    name: 'Melting (Fusion)',
                    startQ: Q_end_ice,
                    endQ: Q_end_melting,
                    startT: props.T_melting,
                    endT: props.T_melting,
                    color: '#7c3aed',
                    formula: 'Q = mL_f',
                    formulaExpanded: 'Q = m √ó L_fusion',
                    description: 'Temperature stays at ' + props.T_melting + '¬∞C while ice melts to water. All energy breaks the hydrogen bonds in ice\'s crystalline structure. L_fusion = ' + props.L_fusion + ' J/g',
                    type: 'latent',
                    latentHeat: props.L_fusion
                },
                {
                    name: 'Heating Water',
                    startQ: Q_end_melting,
                    endQ: Q_end_water,
                    startT: props.T_melting,
                    endT: props.T_boiling,
                    color: '#4dabf7',
                    formula: 'Q = mcŒîT',
                    formulaExpanded: 'Q = m √ó c_water √ó ŒîT',
                    description: 'Liquid water absorbs heat and temperature rises. H‚ÇÇO molecules move faster, colliding more energetically. c_water = ' + props.c_water + ' J/g¬∞C',
                    type: 'sensible',
                    specificHeat: props.c_water
                },
                {
                    name: 'Boiling (Vaporization)',
                    startQ: Q_end_water,
                    endQ: Q_end_boiling,
                    startT: props.T_boiling,
                    endT: props.T_boiling,
                    color: '#ff6b35',
                    formula: 'Q = mL_v',
                    formulaExpanded: 'Q = m √ó L_vaporization',
                    description: 'Temperature stays at ' + props.T_boiling + '¬∞C while water boils to steam. All energy overcomes atmospheric pressure and breaks remaining hydrogen bonds. L_vap = ' + props.L_vaporization + ' J/g',
                    type: 'latent',
                    latentHeat: props.L_vaporization
                },
                {
                    name: 'Heating Steam',
                    startQ: Q_end_boiling,
                    endQ: Q_total,
                    startT: props.T_boiling,
                    endT: props.T_max,
                    color: '#ffa94d',
                    formula: 'Q = mcŒîT',
                    formulaExpanded: 'Q = m √ó c_steam √ó ŒîT',
                    description: 'Steam absorbs heat and temperature rises. H‚ÇÇO gas molecules move even faster with greater kinetic energy. c_steam = ' + props.c_steam + ' J/g¬∞C',
                    type: 'sensible',
                    specificHeat: props.c_steam
                }
            ];
        }

        const heatingCurveSegments = calculateHeatingCurveSegments();
        const MAX_Q = heatingCurveSegments[heatingCurveSegments.length - 1].endQ;

        // Canvas setup
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const wrapper = canvas.parentElement;
            const rect = wrapper.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Simulation state
        let temperature = -20;
        let showTrails = true;
        let molecules = [];
        let vaporMolecules = [];
        let tracer = null;
        let tracerTrail = [];
        let bubbles = [];

        // Constants
        const BOILING_POINT = WATER_PROPERTIES.T_boiling;
        const MELTING_POINT = WATER_PROPERTIES.T_melting;
        const MOLECULE_RADIUS = 3;
        const TRACER_RADIUS = 10;
        const MAX_TRAIL_LENGTH = 120;
        const BOLTZMANN_K = 1.38e-23;
        const WATER_MASS = 2.99e-26;

        // Container bounds (beaker-like visualization)
        function getContainerBounds() {
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            const margin = 40;
            const containerWidth = Math.min(width - margin * 2, 500);
            const containerHeight = height - margin * 2 - 30;
            const containerX = (width - containerWidth) / 2;
            const containerY = margin + 20;
            return {
                x: containerX,
                y: containerY,
                width: containerWidth,
                height: containerHeight,
                bottom: containerY + containerHeight,
                right: containerX + containerWidth
            };
        }

        function getCurrentPhase() {
            if (temperature <= MELTING_POINT) return 'solid';
            if (temperature >= BOILING_POINT) return 'boiling';
            return 'liquid';
        }

        function tempToKelvin(celsius) {
            return Math.max(celsius + 273.15, 10);
        }

        function sampleMaxwellBoltzmannSpeed(T_kelvin, massScale = 1) {
            const sigma = Math.sqrt(BOLTZMANN_K * T_kelvin / (WATER_MASS * massScale));
            const u1 = Math.random();
            const u2 = Math.random();
            const vx = sigma * Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            const vy = sigma * Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);
            return { vx, vy, speed: Math.sqrt(vx * vx + vy * vy) };
        }

        function getVisualSpeedScale(T_kelvin) {
            const rmsSpeed = Math.sqrt(3 * BOLTZMANN_K * T_kelvin / WATER_MASS);
            return 4 / rmsSpeed;
        }

        function initMolecules() {
            const bounds = getContainerBounds();
            const T_kelvin = tempToKelvin(temperature);
            const scale = getVisualSpeedScale(T_kelvin);

            molecules = [];
            vaporMolecules = [];
            tracerTrail = [];
            bubbles = [];

            const phase = getCurrentPhase();

            if (phase === 'solid') {
                // Create solid molecules in lattice pattern
                const gridSpacing = 14;
                const rows = Math.floor((bounds.height - 40) / gridSpacing);
                const cols = Math.floor((bounds.width - 40) / gridSpacing);
                const offsetX = (bounds.width - cols * gridSpacing) / 2;
                const offsetY = (bounds.height - rows * gridSpacing) / 2;

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const hexOffset = (row % 2) * (gridSpacing / 2);
                        const x = bounds.x + offsetX + col * gridSpacing + hexOffset;
                        const y = bounds.y + offsetY + row * gridSpacing;
                        molecules.push({
                            baseX: x,
                            baseY: y,
                            x: x,
                            y: y,
                            vx: 0,
                            vy: 0,
                            phase: Math.random() * Math.PI * 2,
                            type: 'solid'
                        });
                    }
                }
            } else {
                // Create liquid molecules
                const numMolecules = 150;
                for (let i = 0; i < numMolecules; i++) {
                    const vel = sampleMaxwellBoltzmannSpeed(T_kelvin);
                    molecules.push({
                        x: bounds.x + 20 + Math.random() * (bounds.width - 40),
                        y: bounds.y + 20 + Math.random() * (bounds.height - 40),
                        vx: vel.vx * scale,
                        vy: vel.vy * scale,
                        baseSpeed: vel.speed,
                        type: 'liquid'
                    });
                }
            }

            // Create tracer particle
            tracer = {
                x: bounds.x + bounds.width / 2,
                y: bounds.y + bounds.height / 2,
                vx: 0,
                vy: 0
            };
        }

        initMolecules();

        function transitionMolecules() {
            const bounds = getContainerBounds();
            const T_kelvin = tempToKelvin(temperature);
            const scale = getVisualSpeedScale(T_kelvin);
            const phase = getCurrentPhase();

            if (phase === 'solid') {
                // Convert all to solid lattice if not already
                if (molecules.length === 0 || molecules[0].type !== 'solid') {
                    molecules = [];
                    const gridSpacing = 14;
                    const rows = Math.floor((bounds.height - 40) / gridSpacing);
                    const cols = Math.floor((bounds.width - 40) / gridSpacing);
                    const offsetX = (bounds.width - cols * gridSpacing) / 2;
                    const offsetY = (bounds.height - rows * gridSpacing) / 2;

                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const hexOffset = (row % 2) * (gridSpacing / 2);
                            const x = bounds.x + offsetX + col * gridSpacing + hexOffset;
                            const y = bounds.y + offsetY + row * gridSpacing;
                            molecules.push({
                                baseX: x,
                                baseY: y,
                                x: x,
                                y: y,
                                vx: 0,
                                vy: 0,
                                phase: Math.random() * Math.PI * 2,
                                type: 'solid'
                            });
                        }
                    }
                }
                vaporMolecules = [];
            } else if (phase === 'liquid' || phase === 'boiling') {
                // Convert solid to liquid if needed
                if (molecules.length > 0 && molecules[0].type === 'solid') {
                    const newMolecules = [];
                    const numMolecules = 150;
                    for (let i = 0; i < numMolecules; i++) {
                        const vel = sampleMaxwellBoltzmannSpeed(T_kelvin);
                        newMolecules.push({
                            x: bounds.x + 20 + Math.random() * (bounds.width - 40),
                            y: bounds.y + 20 + Math.random() * (bounds.height - 40),
                            vx: vel.vx * scale,
                            vy: vel.vy * scale,
                            baseSpeed: vel.speed,
                            type: 'liquid'
                        });
                    }
                    molecules = newMolecules;
                }
            }
        }

        function updateMolecules() {
            const bounds = getContainerBounds();
            const T_kelvin = tempToKelvin(temperature);
            const scale = getVisualSpeedScale(T_kelvin);
            const phase = getCurrentPhase();

            transitionMolecules();

            if (phase === 'solid') {
                // Solid: vibration only
                const vibrationAmplitude = Math.min(3, 1 + (temperature + 20) / 20);
                molecules.forEach(mol => {
                    mol.phase += 0.08 + Math.random() * 0.04;
                    mol.x = mol.baseX + Math.sin(mol.phase) * vibrationAmplitude;
                    mol.y = mol.baseY + Math.cos(mol.phase * 1.3) * vibrationAmplitude;
                });

                // Tracer minimal movement
                let forceX = 0;
                let forceY = 0;
                molecules.forEach(mol => {
                    const dx = tracer.x - mol.x;
                    const dy = tracer.y - mol.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < TRACER_RADIUS + MOLECULE_RADIUS + 10) {
                        const force = vibrationAmplitude * 0.02 / (dist + 1);
                        forceX += (dx / dist) * force;
                        forceY += (dy / dist) * force;
                    }
                });
                tracer.vx += forceX;
                tracer.vy += forceY;
                tracer.vx *= 0.85;
                tracer.vy *= 0.85;
                tracer.x += tracer.vx;
                tracer.y += tracer.vy;

            } else {
                // Liquid/Boiling: free movement
                const liquidLevel = phase === 'boiling' ? bounds.y + bounds.height * 0.4 : bounds.y;

                molecules.forEach(mol => {
                    mol.x += mol.vx;
                    mol.y += mol.vy;

                    // Boundary collisions
                    if (mol.x < bounds.x + MOLECULE_RADIUS) {
                        mol.vx = Math.abs(mol.vx);
                        mol.x = bounds.x + MOLECULE_RADIUS;
                    }
                    if (mol.x > bounds.right - MOLECULE_RADIUS) {
                        mol.vx = -Math.abs(mol.vx);
                        mol.x = bounds.right - MOLECULE_RADIUS;
                    }
                    if (mol.y < liquidLevel + MOLECULE_RADIUS) {
                        mol.vy = Math.abs(mol.vy);
                        mol.y = liquidLevel + MOLECULE_RADIUS;
                    }
                    if (mol.y > bounds.bottom - MOLECULE_RADIUS) {
                        mol.vy = -Math.abs(mol.vy);
                        mol.y = bounds.bottom - MOLECULE_RADIUS;
                    }

                    // Random velocity updates
                    if (Math.random() < 0.02) {
                        const vel = sampleMaxwellBoltzmannSpeed(T_kelvin);
                        mol.vx = vel.vx * scale;
                        mol.vy = vel.vy * scale;
                        mol.baseSpeed = vel.speed;
                    }
                });

                // Tracer Brownian motion
                let forceX = 0;
                let forceY = 0;
                molecules.forEach(mol => {
                    const dx = tracer.x - mol.x;
                    const dy = tracer.y - mol.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < TRACER_RADIUS + MOLECULE_RADIUS + 8) {
                        const molSpeed = Math.sqrt(mol.vx * mol.vx + mol.vy * mol.vy);
                        const force = molSpeed * 0.2 / (dist + 1);
                        forceX += (dx / dist) * force;
                        forceY += (dy / dist) * force;
                    }
                });
                tracer.vx += forceX;
                tracer.vy += forceY;
                tracer.vx *= 0.92;
                tracer.vy *= 0.92;
                tracer.x += tracer.vx;
                tracer.y += tracer.vy;

                // Keep tracer in liquid region
                tracer.x = Math.max(bounds.x + TRACER_RADIUS, Math.min(bounds.right - TRACER_RADIUS, tracer.x));
                tracer.y = Math.max(liquidLevel + TRACER_RADIUS + 20, Math.min(bounds.bottom - TRACER_RADIUS, tracer.y));
            }

            // Boiling: generate bubbles and vapor
            if (phase === 'boiling') {
                // Create bubbles
                if (Math.random() < 0.15) {
                    bubbles.push({
                        x: bounds.x + 30 + Math.random() * (bounds.width - 60),
                        y: bounds.bottom - 10,
                        radius: 3 + Math.random() * 6,
                        vy: -1 - Math.random() * 2,
                        vx: (Math.random() - 0.5) * 0.5
                    });
                }

                // Update bubbles
                const liquidSurface = bounds.y + bounds.height * 0.4;
                bubbles = bubbles.filter(bubble => {
                    bubble.y += bubble.vy;
                    bubble.x += bubble.vx;
                    bubble.radius *= 1.01; // Bubbles expand as they rise

                    // When bubble reaches surface, create vapor
                    if (bubble.y < liquidSurface) {
                        const vel = sampleMaxwellBoltzmannSpeed(T_kelvin, 0.7);
                        vaporMolecules.push({
                            x: bubble.x,
                            y: liquidSurface - 5,
                            vx: vel.vx * scale * 1.5,
                            vy: -Math.abs(vel.vy * scale * 2),
                            baseSpeed: vel.speed,
                            alpha: 1
                        });
                        return false;
                    }
                    return true;
                });

                // Update vapor molecules
                vaporMolecules.forEach(vapor => {
                    vapor.x += vapor.vx;
                    vapor.y += vapor.vy;
                    vapor.vy -= 0.02; // Rising
                    vapor.alpha -= 0.008;

                    // Boundary
                    if (vapor.x < bounds.x) vapor.vx = Math.abs(vapor.vx);
                    if (vapor.x > bounds.right) vapor.vx = -Math.abs(vapor.vx);
                });

                // Remove faded vapor
                vaporMolecules = vaporMolecules.filter(v => v.alpha > 0 && v.y > bounds.y - 50);

                // Limit vapor count
                if (vaporMolecules.length > 80) {
                    vaporMolecules = vaporMolecules.slice(-80);
                }
            }

            // Update trail
            if (showTrails) {
                tracerTrail.push({ x: tracer.x, y: tracer.y });
                if (tracerTrail.length > MAX_TRAIL_LENGTH) tracerTrail.shift();
            }

            // Update stats
            updateStats();
        }

        function updateStats() {
            const phase = getCurrentPhase();
            let phaseText = 'SOLID';
            let avgSpeed = 0;
            let count = molecules.length;

            if (phase === 'solid') {
                phaseText = 'ICE';
                avgSpeed = Math.round(150 + (temperature + 20) * 3);
            } else if (phase === 'liquid') {
                phaseText = 'WATER';
                let totalSpeed = 0;
                molecules.forEach(mol => { totalSpeed += mol.baseSpeed || 0; });
                avgSpeed = molecules.length > 0 ? Math.round(totalSpeed / molecules.length) : 0;
            } else {
                phaseText = 'BOILING';
                let totalSpeed = 0;
                molecules.forEach(mol => { totalSpeed += mol.baseSpeed || 0; });
                avgSpeed = molecules.length > 0 ? Math.round(totalSpeed / molecules.length) : 0;
                count = molecules.length + vaporMolecules.length;
            }

            document.getElementById('currentPhase').textContent = phaseText;
            document.getElementById('avgSpeed').textContent = avgSpeed;
            document.getElementById('moleculeCount').textContent = count;
        }

        function draw() {
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            const bounds = getContainerBounds();
            const phase = getCurrentPhase();

            ctx.clearRect(0, 0, width, height);

            // Background
            const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
            bgGrad.addColorStop(0, '#0d0d1a');
            bgGrad.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            // Container (beaker)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(bounds.x, bounds.y);
            ctx.lineTo(bounds.x, bounds.bottom);
            ctx.lineTo(bounds.right, bounds.bottom);
            ctx.lineTo(bounds.right, bounds.y);
            ctx.stroke();

            // Container fill based on phase
            if (phase === 'solid') {
                // Ice fill
                const iceGrad = ctx.createLinearGradient(bounds.x, bounds.y, bounds.x, bounds.bottom);
                iceGrad.addColorStop(0, 'rgba(0, 212, 170, 0.15)');
                iceGrad.addColorStop(1, 'rgba(0, 212, 170, 0.25)');
                ctx.fillStyle = iceGrad;
                ctx.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

                // Ice crystal pattern overlay
                ctx.strokeStyle = 'rgba(0, 212, 170, 0.1)';
                ctx.lineWidth = 1;
                for (let x = bounds.x; x < bounds.right; x += 20) {
                    ctx.beginPath();
                    ctx.moveTo(x, bounds.y);
                    ctx.lineTo(x + 10, bounds.bottom);
                    ctx.stroke();
                }
            } else if (phase === 'liquid') {
                // Water fill
                const waterGrad = ctx.createLinearGradient(bounds.x, bounds.y, bounds.x, bounds.bottom);
                waterGrad.addColorStop(0, 'rgba(77, 171, 247, 0.15)');
                waterGrad.addColorStop(1, 'rgba(77, 171, 247, 0.3)');
                ctx.fillStyle = waterGrad;
                ctx.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
            } else {
                // Boiling: liquid below, vapor above
                const liquidSurface = bounds.y + bounds.height * 0.4;

                // Vapor region
                const vaporGrad = ctx.createLinearGradient(bounds.x, bounds.y, bounds.x, liquidSurface);
                vaporGrad.addColorStop(0, 'rgba(255, 169, 77, 0.05)');
                vaporGrad.addColorStop(1, 'rgba(255, 169, 77, 0.15)');
                ctx.fillStyle = vaporGrad;
                ctx.fillRect(bounds.x, bounds.y, bounds.width, liquidSurface - bounds.y);

                // Liquid region
                const waterGrad = ctx.createLinearGradient(bounds.x, liquidSurface, bounds.x, bounds.bottom);
                waterGrad.addColorStop(0, 'rgba(77, 171, 247, 0.2)');
                waterGrad.addColorStop(1, 'rgba(255, 107, 53, 0.3)');
                ctx.fillStyle = waterGrad;
                ctx.fillRect(bounds.x, liquidSurface, bounds.width, bounds.bottom - liquidSurface);

                // Wavy surface line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const time = Date.now() / 200;
                for (let x = bounds.x; x <= bounds.right; x += 5) {
                    const waveY = liquidSurface + Math.sin((x - bounds.x) / 20 + time) * 3;
                    if (x === bounds.x) {
                        ctx.moveTo(x, waveY);
                    } else {
                        ctx.lineTo(x, waveY);
                    }
                }
                ctx.stroke();
            }

            // Draw bubbles (boiling)
            if (phase === 'boiling') {
                bubbles.forEach(bubble => {
                    ctx.beginPath();
                    ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            }

            // Draw vapor molecules
            vaporMolecules.forEach(vapor => {
                ctx.beginPath();
                ctx.arc(vapor.x, vapor.y, MOLECULE_RADIUS * 1.2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 169, 77, ' + (vapor.alpha * 0.8) + ')';
                ctx.fill();

                // Glow
                ctx.beginPath();
                ctx.arc(vapor.x, vapor.y, MOLECULE_RADIUS * 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 169, 77, ' + (vapor.alpha * 0.2) + ')';
                ctx.fill();
            });

            // Draw trail
            if (showTrails && tracerTrail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(tracerTrail[0].x, tracerTrail[0].y);
                for (let i = 1; i < tracerTrail.length; i++) {
                    ctx.lineTo(tracerTrail[i].x, tracerTrail[i].y);
                }
                const trailGrad = ctx.createLinearGradient(
                    tracerTrail[0].x, tracerTrail[0].y,
                    tracerTrail[tracerTrail.length - 1].x, tracerTrail[tracerTrail.length - 1].y
                );
                trailGrad.addColorStop(0, 'rgba(247, 37, 133, 0)');
                trailGrad.addColorStop(1, 'rgba(247, 37, 133, 0.5)');
                ctx.strokeStyle = trailGrad;
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw molecules
            molecules.forEach(mol => {
                let color, glowColor;

                if (mol.type === 'solid') {
                    color = '#00d4aa';
                    glowColor = 'rgba(0, 212, 170, 0.3)';
                } else {
                    const speed = Math.sqrt(mol.vx * mol.vx + mol.vy * mol.vy);
                    const intensity = Math.min(speed / 4, 1);

                    if (phase === 'boiling') {
                        const r = Math.floor(77 + (255 - 77) * intensity);
                        const g = Math.floor(171 + (107 - 171) * intensity);
                        const b = Math.floor(247 + (53 - 247) * intensity);
                        color = 'rgb(' + r + ',' + g + ',' + b + ')';
                        glowColor = 'rgba(255, 107, 53, ' + (0.2 + 0.2 * intensity) + ')';
                    } else {
                        const blue = Math.floor(171 + 84 * intensity);
                        color = 'rgb(77, ' + blue + ', 247)';
                        glowColor = 'rgba(77, 171, 247, ' + (0.2 + 0.15 * intensity) + ')';
                    }
                }

                // Glow
                ctx.beginPath();
                ctx.arc(mol.x, mol.y, MOLECULE_RADIUS + 2, 0, Math.PI * 2);
                ctx.fillStyle = glowColor;
                ctx.fill();

                // Molecule
                ctx.beginPath();
                ctx.arc(mol.x, mol.y, MOLECULE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            });

            // Draw tracer
            ctx.beginPath();
            ctx.arc(tracer.x, tracer.y, TRACER_RADIUS + 8, 0, Math.PI * 2);
            const glowGrad = ctx.createRadialGradient(tracer.x, tracer.y, TRACER_RADIUS, tracer.x, tracer.y, TRACER_RADIUS + 8);
            glowGrad.addColorStop(0, 'rgba(247, 37, 133, 0.5)');
            glowGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGrad;
            ctx.fill();

            ctx.beginPath();
            ctx.arc(tracer.x, tracer.y, TRACER_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = '#f72585';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Phase label
            ctx.font = 'bold 14px JetBrains Mono';
            ctx.textAlign = 'center';
            let labelColor, labelText;
            if (phase === 'solid') {
                labelColor = '#00d4aa';
                labelText = 'üßä ICE (Solid)';
            } else if (phase === 'liquid') {
                labelColor = '#4dabf7';
                labelText = 'üíß WATER (Liquid)';
            } else {
                labelColor = '#ff6b35';
                labelText = 'üí® BOILING (Liquid + Vapor)';
            }
            ctx.fillStyle = labelColor;
            ctx.fillText(labelText, width / 2, bounds.y - 8);

            // Temperature indicator on container
            ctx.font = '12px JetBrains Mono';
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fillText(temperature + '¬∞C', bounds.x + 8, bounds.bottom - 8);
        }

        function animate() {
            updateMolecules();
            draw();
            requestAnimationFrame(animate);
        }

        animate();

        // ========== HEATING CURVE CHART ==========
        const chartCanvas = document.getElementById('heatingCurveCanvas');
        const chartCtx = chartCanvas.getContext('2d');
        const tooltip = document.getElementById('chartTooltip');
        let tooltipVisible = false;

        function resizeChartCanvas() {
            const wrapper = chartCanvas.parentElement;
            const rect = wrapper.getBoundingClientRect();
            chartCanvas.width = rect.width * window.devicePixelRatio;
            chartCanvas.height = rect.height * window.devicePixelRatio;
            chartCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
            chartCanvas.style.width = rect.width + 'px';
            chartCanvas.style.height = rect.height + 'px';
            drawHeatingCurve();
        }

        resizeChartCanvas();
        window.addEventListener('resize', resizeChartCanvas);

        function getChartDimensions() {
            const width = chartCanvas.width / window.devicePixelRatio;
            const height = chartCanvas.height / window.devicePixelRatio;
            return {
                width: width,
                height: height,
                margin: { top: 40, right: 30, bottom: 60, left: 60 },
                plotWidth: width - 90,
                plotHeight: height - 100
            };
        }

        function dataToPixel(Q, T) {
            const dim = getChartDimensions();
            const minT = WATER_PROPERTIES.T_min - 10;
            const maxT = WATER_PROPERTIES.T_max + 10;
            const x = dim.margin.left + (Q / MAX_Q) * dim.plotWidth;
            const y = dim.margin.top + dim.plotHeight - ((T - minT) / (maxT - minT)) * dim.plotHeight;
            return { x: x, y: y };
        }

        function pixelToData(px, py) {
            const dim = getChartDimensions();
            const minT = WATER_PROPERTIES.T_min - 10;
            const maxT = WATER_PROPERTIES.T_max + 10;
            const Q = ((px - dim.margin.left) / dim.plotWidth) * MAX_Q;
            const T = minT + ((dim.margin.top + dim.plotHeight - py) / dim.plotHeight) * (maxT - minT);
            return { Q: Q, T: T };
        }

        function findSegmentAtPoint(px, py) {
            const data = pixelToData(px, py);
            if (data.Q < 0 || data.Q > MAX_Q) return null;

            for (const seg of heatingCurveSegments) {
                if (data.Q >= seg.startQ && data.Q <= seg.endQ) {
                    let expectedT;
                    if (seg.startT === seg.endT) {
                        expectedT = seg.startT;
                    } else {
                        const ratio = (data.Q - seg.startQ) / (seg.endQ - seg.startQ);
                        expectedT = seg.startT + ratio * (seg.endT - seg.startT);
                    }
                    if (Math.abs(data.T - expectedT) < 20) {
                        return seg;
                    }
                }
            }
            return null;
        }

        function getCurrentQFromTemp(temp) {
            for (const seg of heatingCurveSegments) {
                if (temp >= seg.startT && temp <= seg.endT) {
                    if (seg.startT === seg.endT) {
                        return (seg.startQ + seg.endQ) / 2;
                    } else {
                        const ratio = (temp - seg.startT) / (seg.endT - seg.startT);
                        return seg.startQ + ratio * (seg.endQ - seg.startQ);
                    }
                }
            }
            if (temp < WATER_PROPERTIES.T_min) return 0;
            if (temp > WATER_PROPERTIES.T_max) return MAX_Q;
            return 0;
        }

        function drawHeatingCurve() {
            const dim = getChartDimensions();
            const minT = WATER_PROPERTIES.T_min - 10;
            const maxT = WATER_PROPERTIES.T_max + 10;

            chartCtx.clearRect(0, 0, dim.width, dim.height);
            chartCtx.fillStyle = '#0d0d1a';
            chartCtx.fillRect(0, 0, dim.width, dim.height);

            // Grid
            chartCtx.strokeStyle = 'rgba(124, 58, 237, 0.1)';
            chartCtx.lineWidth = 1;

            for (let t = -20; t <= 160; t += 20) {
                const p = dataToPixel(0, t);
                chartCtx.beginPath();
                chartCtx.moveTo(dim.margin.left, p.y);
                chartCtx.lineTo(dim.margin.left + dim.plotWidth, p.y);
                chartCtx.stroke();
            }

            const qStep = Math.pow(10, Math.floor(Math.log10(MAX_Q / 5)));
            for (let q = 0; q <= MAX_Q; q += qStep) {
                const p = dataToPixel(q, 0);
                chartCtx.beginPath();
                chartCtx.moveTo(p.x, dim.margin.top);
                chartCtx.lineTo(p.x, dim.margin.top + dim.plotHeight);
                chartCtx.stroke();
            }

            // Phase lines
            chartCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            chartCtx.setLineDash([5, 5]);
            const p0 = dataToPixel(0, WATER_PROPERTIES.T_melting);
            chartCtx.beginPath();
            chartCtx.moveTo(dim.margin.left, p0.y);
            chartCtx.lineTo(dim.margin.left + dim.plotWidth, p0.y);
            chartCtx.stroke();

            const p100 = dataToPixel(0, WATER_PROPERTIES.T_boiling);
            chartCtx.beginPath();
            chartCtx.moveTo(dim.margin.left, p100.y);
            chartCtx.lineTo(dim.margin.left + dim.plotWidth, p100.y);
            chartCtx.stroke();
            chartCtx.setLineDash([]);

            chartCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            chartCtx.font = '10px JetBrains Mono';
            chartCtx.textAlign = 'right';
            chartCtx.fillText(WATER_PROPERTIES.T_melting + '¬∞C (Melting)', dim.margin.left + dim.plotWidth - 5, p0.y - 5);
            chartCtx.fillText(WATER_PROPERTIES.T_boiling + '¬∞C (Boiling)', dim.margin.left + dim.plotWidth - 5, p100.y - 5);

            // Curve segments
            heatingCurveSegments.forEach(function(seg) {
                const start = dataToPixel(seg.startQ, seg.startT);
                const end = dataToPixel(seg.endQ, seg.endT);

                chartCtx.beginPath();
                chartCtx.moveTo(start.x, start.y);
                chartCtx.lineTo(end.x, end.y);
                chartCtx.strokeStyle = seg.color;
                chartCtx.lineWidth = 4;
                chartCtx.lineCap = 'round';
                chartCtx.stroke();

                chartCtx.beginPath();
                chartCtx.moveTo(start.x, start.y);
                chartCtx.lineTo(end.x, end.y);
                chartCtx.strokeStyle = seg.color + '40';
                chartCtx.lineWidth = 12;
                chartCtx.stroke();
            });

            // Current position
            const currentQ = getCurrentQFromTemp(temperature);
            const currentP = dataToPixel(currentQ, Math.min(Math.max(temperature, WATER_PROPERTIES.T_min), WATER_PROPERTIES.T_max));

            chartCtx.beginPath();
            chartCtx.moveTo(currentP.x, dim.margin.top + dim.plotHeight);
            chartCtx.lineTo(currentP.x, currentP.y);
            chartCtx.strokeStyle = 'rgba(247, 37, 133, 0.3)';
            chartCtx.lineWidth = 2;
            chartCtx.setLineDash([4, 4]);
            chartCtx.stroke();
            chartCtx.setLineDash([]);

            chartCtx.beginPath();
            chartCtx.arc(currentP.x, currentP.y, 8, 0, Math.PI * 2);
            chartCtx.fillStyle = '#f72585';
            chartCtx.fill();
            chartCtx.strokeStyle = 'white';
            chartCtx.lineWidth = 2;
            chartCtx.stroke();

            chartCtx.beginPath();
            chartCtx.arc(currentP.x, currentP.y, 14, 0, Math.PI * 2);
            chartCtx.fillStyle = 'rgba(247, 37, 133, 0.3)';
            chartCtx.fill();

            // Axes
            chartCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            chartCtx.moveTo(dim.margin.left, dim.margin.top);
            chartCtx.lineTo(dim.margin.left, dim.margin.top + dim.plotHeight);
            chartCtx.stroke();
            chartCtx.beginPath();
            chartCtx.moveTo(dim.margin.left, dim.margin.top + dim.plotHeight);
            chartCtx.lineTo(dim.margin.left + dim.plotWidth, dim.margin.top + dim.plotHeight);
            chartCtx.stroke();

            chartCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            chartCtx.font = '12px Space Grotesk';
            chartCtx.textAlign = 'center';
            chartCtx.fillText('Heat Added (Q) ‚Üí', dim.margin.left + dim.plotWidth / 2, dim.height - 10);

            chartCtx.save();
            chartCtx.translate(15, dim.margin.top + dim.plotHeight / 2);
            chartCtx.rotate(-Math.PI / 2);
            chartCtx.fillText('Temperature (¬∞C) ‚Üí', 0, 0);
            chartCtx.restore();

            chartCtx.font = '10px JetBrains Mono';
            chartCtx.textAlign = 'right';
            for (let t = -20; t <= 160; t += 40) {
                const p = dataToPixel(0, t);
                chartCtx.fillText(t + '¬∞', dim.margin.left - 8, p.y + 4);
            }

            // Formulas
            chartCtx.font = 'bold 11px JetBrains Mono';
            chartCtx.textAlign = 'center';

            const waterSeg = heatingCurveSegments[2];
            const sensibleMidQ = (waterSeg.startQ + waterSeg.endQ) / 2;
            const sensibleMidT = (waterSeg.startT + waterSeg.endT) / 2;
            const sensibleP = dataToPixel(sensibleMidQ, sensibleMidT);
            chartCtx.fillStyle = '#4dabf7';
            chartCtx.fillText('Q = mcŒîT', sensibleP.x, sensibleP.y - 15);

            const fusionSeg = heatingCurveSegments[1];
            const fusionMidQ = (fusionSeg.startQ + fusionSeg.endQ) / 2;
            const fusionP = dataToPixel(fusionMidQ, WATER_PROPERTIES.T_melting);
            chartCtx.fillStyle = '#7c3aed';
            chartCtx.fillText('Q = mL', fusionP.x, fusionP.y - 15);
            chartCtx.font = '9px JetBrains Mono';
            chartCtx.fillText('(Latent Heat)', fusionP.x, fusionP.y + 15);

            const vapSeg = heatingCurveSegments[3];
            const vapMidQ = (vapSeg.startQ + vapSeg.endQ) / 2;
            const vapP = dataToPixel(vapMidQ, WATER_PROPERTIES.T_boiling);
            chartCtx.font = 'bold 11px JetBrains Mono';
            chartCtx.fillStyle = '#ff6b35';
            chartCtx.fillText('Q = mL', vapP.x, vapP.y - 15);
            chartCtx.font = '9px JetBrains Mono';
            chartCtx.fillText('(Latent Heat)', vapP.x, vapP.y + 15);
        }

        function showTooltip(segment, x, y) {
            const rect = chartCanvas.getBoundingClientRect();
            tooltip.classList.add('visible');
            tooltip.querySelector('.tooltip-title').textContent = segment.name;
            tooltip.querySelector('.tooltip-formula').textContent = segment.formulaExpanded;
            tooltip.querySelector('.tooltip-desc').textContent = segment.description;

            let tooltipX = x + 15;
            let tooltipY = y - 10;

            if (tooltipX + 280 > rect.width) {
                tooltipX = x - 290;
            }
            if (tooltipY + 120 > rect.height) {
                tooltipY = rect.height - 130;
            }
            if (tooltipY < 0) tooltipY = 10;

            tooltip.style.left = tooltipX + 'px';
            tooltip.style.top = tooltipY + 'px';
            tooltipVisible = true;
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
            tooltipVisible = false;
        }

        // Mouse interaction
        chartCanvas.addEventListener('mousemove', function(e) {
            if (tooltipVisible) return;
            const rect = chartCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const segment = findSegmentAtPoint(x, y);
            if (segment) {
                showTooltip(segment, x, y);
            }
        });

        chartCanvas.addEventListener('click', function(e) {
            if (tooltipVisible) {
                hideTooltip();
                return;
            }
            const rect = chartCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const segment = findSegmentAtPoint(x, y);
            if (segment) {
                showTooltip(segment, x, y);
            }
        });

        tooltip.addEventListener('click', function() {
            hideTooltip();
        });

        // Touch interaction
        chartCanvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (tooltipVisible) {
                hideTooltip();
                return;
            }
            const rect = chartCanvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            const segment = findSegmentAtPoint(x, y);
            if (segment) {
                showTooltip(segment, x, y);
            }
        });

        // Temperature slider
        const tempSlider = document.getElementById('tempSlider');
        const tempValue = document.getElementById('tempValue');
        const phaseSolid = document.getElementById('phaseSolid');
        const phaseLiquid = document.getElementById('phaseLiquid');
        const phaseVapor = document.getElementById('phaseVapor');
        const infoSolid = document.getElementById('infoSolid');
        const infoLiquid = document.getElementById('infoLiquid');
        const infoVapor = document.getElementById('infoVapor');
        const infoMelting = document.getElementById('infoMelting');
        const infoBoiling = document.getElementById('infoBoiling');

        tempSlider.addEventListener('input', function(e) {
            temperature = parseInt(e.target.value);
            tempValue.textContent = temperature + '¬∞C';

            phaseSolid.classList.remove('active');
            phaseLiquid.classList.remove('active');
            phaseVapor.classList.remove('active');
            infoSolid.classList.remove('active');
            infoLiquid.classList.remove('active');
            infoVapor.classList.remove('active');
            infoMelting.classList.remove('active');
            infoBoiling.classList.remove('active');

            if (temperature <= MELTING_POINT) {
                phaseSolid.classList.add('active');
                infoSolid.classList.add('active');
                if (temperature === MELTING_POINT) {
                    infoMelting.classList.add('active');
                }
            } else if (temperature < BOILING_POINT) {
                phaseLiquid.classList.add('active');
                infoLiquid.classList.add('active');
            } else {
                phaseVapor.classList.add('active');
                infoVapor.classList.add('active');
                infoBoiling.classList.add('active');
            }

            drawHeatingCurve();
        });

        // Trail toggle
        document.getElementById('btnTrailOn').addEventListener('click', function() {
            showTrails = true;
            document.getElementById('btnTrailOn').classList.add('active');
            document.getElementById('btnTrailOff').classList.remove('active');
        });

        document.getElementById('btnTrailOff').addEventListener('click', function() {
            showTrails = false;
            tracerTrail = [];
            document.getElementById('btnTrailOff').classList.add('active');
            document.getElementById('btnTrailOn').classList.remove('active');
        });

        drawHeatingCurve();
    </script>
</body>
</html>

