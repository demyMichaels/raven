<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Motion Visualizer</title>
    <!-- TailwindCSS for responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MathJS for mathematical calculations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script>
        // Tailwind configuration with custom theme and dark mode
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        velocity: '#FF6B6B',
                        acceleration: '#4ECDC4',
                    }
                }
            }
        }
        
        // Dark mode detection and handling
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        
        // Listen for dark mode changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
    </script>
</head>
<body class="bg-gray-900 text-white min-h-screen overflow-hidden">
    <!-- Game-style full screen layout -->
    <div class="relative w-full h-screen flex flex-col">
        
        <!-- Top HUD Bar -->
        <div class="absolute top-0 left-0 right-0 z-20 p-3 bg-gradient-to-b from-black/80 to-transparent">
            <div class="flex justify-between items-center">
                <!-- Title and Status -->
                <div class="flex items-center space-x-4">
                    <h1 class="text-lg sm:text-xl font-bold text-primary">Physics Motion</h1>
                    <div class="text-sm bg-black/50 px-3 py-1 rounded-full" id="status-display">Ready to Setup</div>
                </div>
                
                <!-- Timer Display -->
                <div class="text-right">
                    <div class="text-2xl font-bold text-primary" id="timer-display">0.00s</div>
                    <div class="text-xs opacity-75">Elapsed Time</div>
                </div>
            </div>
        </div>

        <!-- Main 16:9 Canvas Area -->
        <div class="flex-1 flex items-center justify-center p-4 pt-20 pb-32">
            <div class="relative w-full max-w-none" style="aspect-ratio: 16/9;">
                <canvas id="motionMap" class="w-full h-full bg-gradient-to-br from-blue-900 to-indigo-800 rounded-lg shadow-2xl cursor-crosshair touch-manipulation border-2 border-gray-600"></canvas>
                
                <!-- Coordinate overlay -->
                <div class="absolute bottom-2 right-2 bg-black/70 px-2 py-1 rounded text-xs font-mono" id="coordinates">X: 0, Y: 0</div>
                
                <!-- Instructions overlay -->
                <div class="absolute top-2 left-2 bg-black/70 px-3 py-1 rounded text-xs" id="instruction-text">
                    Click to set start point
                </div>
            </div>
        </div>

        <!-- Bottom Control Panel -->
        <div class="absolute bottom-0 left-0 right-0 z-20 p-3 bg-gradient-to-t from-black/90 to-transparent">
            <div class="max-w-6xl mx-auto">
                
                <!-- Main Action Buttons -->
                <div class="flex justify-center space-x-3 mb-3">
                    <button id="start-simulation" class="px-6 py-3 bg-primary hover:bg-opacity-90 text-white rounded-lg font-medium text-base transition-all shadow-lg" disabled>
                        Set Path First
                    </button>
                    <button id="play-pause" class="px-6 py-3 bg-green-500 hover:bg-green-600 text-white rounded-lg font-medium text-base transition-all shadow-lg hidden">
                        ▶ Play
                    </button>
                    <button id="reset-motion" class="px-6 py-3 bg-red-500 hover:bg-red-600 text-white rounded-lg font-medium text-base transition-all shadow-lg">
                        Reset
                    </button>
                </div>

                <!-- Physics Stats Row -->
                <div class="grid grid-cols-4 gap-2 mb-3">
                    <div class="bg-black/70 p-2 rounded text-center">
                        <div class="text-lg font-bold text-velocity" id="current-speed">0</div>
                        <div class="text-xs opacity-75">Speed (m/s)</div>
                    </div>
                    <div class="bg-black/70 p-2 rounded text-center">
                        <div class="text-lg font-bold text-primary" id="distance-traveled">0</div>
                        <div class="text-xs opacity-75">Distance (m)</div>
                    </div>
                    <div class="bg-black/70 p-2 rounded text-center">
                        <div class="text-lg font-bold text-acceleration" id="current-acceleration">0</div>
                        <div class="text-xs opacity-75">Accel (m/s²)</div>
                    </div>
                    <div class="bg-black/70 p-2 rounded text-center">
                        <div class="text-lg font-bold" id="progress-percent">0%</div>
                        <div class="text-xs opacity-75">Progress</div>
                    </div>
                </div>

                <!-- Progress Bar -->
                <div class="w-full bg-gray-600 rounded-full h-2 mb-3">
                    <div id="progress-bar" class="bg-primary h-2 rounded-full transition-all duration-100" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Left Side Panel - Path Info -->
        <div class="absolute left-2 top-1/2 transform -translate-y-1/2 z-10 space-y-2">
            <div class="bg-black/70 p-3 rounded-lg max-w-xs">
                <div class="text-xs font-medium mb-2">Path Info</div>
                <div class="space-y-1 text-xs">
                    <div>Start: <span id="start-coords">Not set</span></div>
                    <div>End: <span id="end-coords">Not set</span></div>
                    <div>Distance: <span id="path-distance">0 m</span></div>
                </div>
                <button id="clear-path" class="w-full mt-2 px-3 py-1 bg-red-500/80 hover:bg-red-500 text-white rounded text-xs transition-all">
                    Clear Path
                </button>
            </div>
        </div>

        <!-- Right Side Panel - Physics Settings -->
        <div class="absolute right-2 top-1/2 transform -translate-y-1/2 z-10 space-y-2">
            <div class="bg-black/70 p-3 rounded-lg max-w-xs">
                <div class="text-xs font-medium mb-2">Physics Settings</div>
                <div class="space-y-2">
                    <div>
                        <label class="block text-xs mb-1">Initial Speed (m/s)</label>
                        <input type="number" id="initial-speed" class="w-full px-2 py-1 bg-gray-800 border border-gray-600 rounded text-xs text-white" value="10" min="0" max="100" step="0.1">
                    </div>
                    <div>
                        <label class="block text-xs mb-1">Acceleration (m/s²)</label>
                        <input type="number" id="acceleration" class="w-full px-2 py-1 bg-gray-800 border border-gray-600 rounded text-xs text-white" value="0" min="-20" max="20" step="0.1">
                    </div>
                    <div>
                        <label class="block text-xs mb-1">Time Scale</label>
                        <select id="time-scale" class="w-full px-2 py-1 bg-gray-800 border border-gray-600 rounded text-xs text-white">
                            <option value="1">Real-time</option>
                            <option value="0.5">Half-speed</option>
                            <option value="0.1">Slow motion</option>
                            <option value="2">Double-speed</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <!-- Legend -->
        <div class="absolute bottom-2 left-2 bg-black/70 p-2 rounded-lg">
            <div class="grid grid-cols-2 gap-2 text-xs">
                <div class="flex items-center gap-1">
                    <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                    <span>Start</span>
                </div>
                <div class="flex items-center gap-1">
                    <div class="w-2 h-2 bg-red-500 rounded-full"></div>
                    <span>End</span>
                </div>
                <div class="flex items-center gap-1">
                    <div class="w-2 h-2 bg-primary rounded-full"></div>
                    <span>Object</span>
                </div>
                <div class="flex items-center gap-1">
                    <div class="w-2 h-1 bg-velocity"></div>
                    <span>Path</span>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        /**
         * Physics Motion Visualizer - Mobile Game Style Interface
         * Features: Full-screen 16:9 visualization, strategic UI placement
         */
        
        // ============================================================================
        // DOM ELEMENT REFERENCES
        // ============================================================================
        
        const statusDisplay = document.getElementById('status-display');
        const instructionText = document.getElementById('instruction-text');
        const startCoordsDisplay = document.getElementById('start-coords');
        const endCoordsDisplay = document.getElementById('end-coords');
        const pathDistanceDisplay = document.getElementById('path-distance');
        const clearPathBtn = document.getElementById('clear-path');
        const initialSpeedInput = document.getElementById('initial-speed');
        const accelerationInput = document.getElementById('acceleration');
        const timeScaleSelect = document.getElementById('time-scale');
        const startSimulationBtn = document.getElementById('start-simulation');
        
        const timerDisplay = document.getElementById('timer-display');
        const currentSpeedDisplay = document.getElementById('current-speed');
        const distanceTraveledDisplay = document.getElementById('distance-traveled');
        const currentAccelerationDisplay = document.getElementById('current-acceleration');
        const progressPercent = document.getElementById('progress-percent');
        const playPauseBtn = document.getElementById('play-pause');
        const resetMotionBtn = document.getElementById('reset-motion');
        const progressBar = document.getElementById('progress-bar');
        
        const motionMap = document.getElementById('motionMap');
        const coordinatesDisplay = document.getElementById('coordinates');
        const ctx = motionMap.getContext('2d');
        
        // ============================================================================
        // APPLICATION STATE MANAGEMENT
        // ============================================================================
        
        let startPoint = null;
        let endPoint = null;
        let pathLength = 0;
        let objectPosition = { x: 0, y: 0 };
        
        let isSimulationRunning = false;
        let isPaused = false;
        let startTime = 0;
        let pausedTime = 0;
        let animationFrame = null;
        
        let initialSpeed = 10;
        let acceleration = 0;
        let timeScale = 1;
        
        let mapWidth, mapHeight;
        
        // ============================================================================
        // EVENT LISTENERS SETUP
        // ============================================================================
        
        clearPathBtn.addEventListener('click', clearPath);
        startSimulationBtn.addEventListener('click', startSimulation);
        playPauseBtn.addEventListener('click', togglePlayPause);
        resetMotionBtn.addEventListener('click', resetMotion);
        
        motionMap.addEventListener('click', handleMapClick);
        motionMap.addEventListener('mousemove', updateCoordinates);
        motionMap.addEventListener('touchmove', handleTouchMove);
        motionMap.addEventListener('touchstart', preventZoom);
        
        initialSpeedInput.addEventListener('input', updatePhysicsParams);
        accelerationInput.addEventListener('input', updatePhysicsParams);
        timeScaleSelect.addEventListener('change', updatePhysicsParams);
        
        window.addEventListener('resize', handleWindowResize);
        
        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        function init() {
            handleWindowResize();
            updatePhysicsParams();
            drawMap();
        }
        
        // ============================================================================
        // RESPONSIVE CANVAS HANDLING
        // ============================================================================
        
        function handleWindowResize() {
            const container = motionMap.parentElement;
            mapWidth = container.offsetWidth;
            mapHeight = container.offsetHeight;
            motionMap.width = mapWidth;
            motionMap.height = mapHeight;
            drawMap();
        }
        
        // ============================================================================
        // TOUCH AND MOBILE INTERACTION HANDLERS
        // ============================================================================
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                updateCoordinates(e.touches[0]);
            }
        }
        
        function preventZoom(e) {
            e.preventDefault();
        }
        
        // ============================================================================
        // MAP INTERACTION FUNCTIONS
        // ============================================================================
        
        function handleMapClick(e) {
            if (isSimulationRunning) return;
            
            const rect = motionMap.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            // Convert to grid coordinates (-20 to +20)
            const x = Math.floor((clientX - rect.left) / rect.width * 40) - 20;
            const y = Math.floor(40 - (clientY - rect.top) / rect.height * 40) - 20;
            
            if (!startPoint) {
                startPoint = { x, y };
                startCoordsDisplay.textContent = `(${x}, ${y})`;
                instructionText.textContent = 'Click to set end point';
                statusDisplay.textContent = 'Setting End Point';
                updateUI();
            } else if (!endPoint) {
                endPoint = { x, y };
                endCoordsDisplay.textContent = `(${x}, ${y})`;
                calculatePathLength();
                instructionText.textContent = 'Path set! Ready to simulate';
                statusDisplay.textContent = 'Ready to Simulate';
                updateUI();
            } else {
                // Reset and set new start point
                startPoint = { x, y };
                endPoint = null;
                startCoordsDisplay.textContent = `(${x}, ${y})`;
                endCoordsDisplay.textContent = 'Not set';
                pathDistanceDisplay.textContent = '0 m';
                instructionText.textContent = 'Click to set end point';
                statusDisplay.textContent = 'Setting End Point';
                updateUI();
            }
            
            drawMap();
        }
        
        function updateCoordinates(e) {
            const rect = motionMap.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            const x = Math.floor((clientX - rect.left) / rect.width * 40) - 20;
            const y = Math.floor(40 - (clientY - rect.top) / rect.height * 40) - 20;
            coordinatesDisplay.textContent = `X: ${x}, Y: ${y}`;
        }
        
        // ============================================================================
        // PATH AND PHYSICS CALCULATION FUNCTIONS
        // ============================================================================
        
        function calculatePathLength() {
            if (startPoint && endPoint) {
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                pathLength = Math.sqrt(dx * dx + dy * dy);
                pathDistanceDisplay.textContent = `${pathLength.toFixed(1)} m`;
            }
        }
        
        function updatePhysicsParams() {
            initialSpeed = parseFloat(initialSpeedInput.value) || 0;
            acceleration = parseFloat(accelerationInput.value) || 0;
            timeScale = parseFloat(timeScaleSelect.value) || 1;
            currentAccelerationDisplay.textContent = acceleration.toFixed(1);
        }
        
        // ============================================================================
        // UI UPDATE FUNCTIONS
        // ============================================================================
        
        function updateUI() {
            const hasPath = startPoint && endPoint;
            startSimulationBtn.disabled = !hasPath;
            startSimulationBtn.textContent = hasPath ? 'Start Simulation' : 'Set Path First';
        }
        
        function clearPath() {
            startPoint = null;
            endPoint = null;
            pathLength = 0;
            startCoordsDisplay.textContent = 'Not set';
            endCoordsDisplay.textContent = 'Not set';
            pathDistanceDisplay.textContent = '0 m';
            instructionText.textContent = 'Click to set start point';
            statusDisplay.textContent = 'Ready to Setup';
            updateUI();
            drawMap();
        }
        
        // ============================================================================
        // SIMULATION CONTROL FUNCTIONS
        // ============================================================================
        
        function startSimulation() {
            if (!startPoint || !endPoint) return;
            
            isSimulationRunning = true;
            isPaused = false;
            startTime = performance.now();
            pausedTime = 0;
            objectPosition = { ...startPoint };
            
            startSimulationBtn.style.display = 'none';
            playPauseBtn.style.display = 'inline-block';
            playPauseBtn.textContent = '⏸ Pause';
            statusDisplay.textContent = 'Simulation Running';
            instructionText.textContent = 'Object is moving!';
            
            animate();
        }
        
        function togglePlayPause() {
            if (!isSimulationRunning) return;
            
            if (isPaused) {
                isPaused = false;
                startTime = performance.now() - pausedTime;
                playPauseBtn.textContent = '⏸ Pause';
                statusDisplay.textContent = 'Simulation Running';
                animate();
            } else {
                isPaused = true;
                pausedTime = performance.now() - startTime;
                playPauseBtn.textContent = '▶ Play';
                statusDisplay.textContent = 'Simulation Paused';
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                }
            }
        }
        
        function resetMotion() {
            isSimulationRunning = false;
            isPaused = false;
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            startSimulationBtn.style.display = 'inline-block';
            playPauseBtn.style.display = 'none';
            playPauseBtn.textContent = '▶ Play';
            
            timerDisplay.textContent = '0.00s';
            currentSpeedDisplay.textContent = '0';
            distanceTraveledDisplay.textContent = '0';
            progressPercent.textContent = '0%';
            progressBar.style.width = '0%';
            
            if (startPoint && endPoint) {
                statusDisplay.textContent = 'Ready to Simulate';
                instructionText.textContent = 'Path set! Ready to simulate';
            } else {
                statusDisplay.textContent = 'Ready to Setup';
                instructionText.textContent = 'Click to set start point';
            }
            
            if (startPoint) {
                objectPosition = { ...startPoint };
            }
            
            drawMap();
        }
        
        // ============================================================================
        // ANIMATION AND PHYSICS SIMULATION
        // ============================================================================
        
        function animate() {
            if (!isSimulationRunning || isPaused) return;
            
            const currentTime = performance.now();
            const elapsedTime = (currentTime - startTime) / 1000 * timeScale;
            
            // Calculate current physics values
            const currentSpeed = initialSpeed + acceleration * elapsedTime;
            const distanceTraveled = initialSpeed * elapsedTime + 0.5 * acceleration * elapsedTime * elapsedTime;
            
            // Update displays
            timerDisplay.textContent = `${elapsedTime.toFixed(2)}s`;
            currentSpeedDisplay.textContent = currentSpeed.toFixed(1);
            distanceTraveledDisplay.textContent = distanceTraveled.toFixed(1);
            
            // Calculate object position along path
            if (pathLength > 0) {
                const progress = Math.min(distanceTraveled / pathLength, 1);
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                
                objectPosition.x = startPoint.x + dx * progress;
                objectPosition.y = startPoint.y + dy * progress;
                
                progressBar.style.width = `${progress * 100}%`;
                progressPercent.textContent = `${(progress * 100).toFixed(0)}%`;
                
                if (progress >= 1) {
                    isSimulationRunning = false;
                    startSimulationBtn.style.display = 'inline-block';
                    playPauseBtn.style.display = 'none';
                    statusDisplay.textContent = 'Destination Reached!';
                    instructionText.textContent = 'Simulation complete!';
                    drawMap();
                    return;
                }
            }
            
            drawMap();
            animationFrame = requestAnimationFrame(animate);
        }
        
        // ============================================================================
        // CANVAS DRAWING FUNCTIONS
        // ============================================================================
        
        function drawMap() {
            ctx.clearRect(0, 0, mapWidth, mapHeight);
            
            drawBackground();
            drawGrid();
            drawAxes();
            drawAxisLabels();
            
            if (startPoint && endPoint) {
                drawPathLine();
            }
            
            drawPoints();
            drawMovingObject();
        }
        
        function drawBackground() {
            const bgGradient = ctx.createLinearGradient(0, 0, mapWidth, mapHeight);
            bgGradient.addColorStop(0, '#1e3a8a');
            bgGradient.addColorStop(1, '#3730a3');
            
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, mapWidth, mapHeight);
        }
        
        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            
            for (let i = 0; i <= 40; i++) {
                const xPos = (i / 40) * mapWidth;
                const yPos = (i / 40) * mapHeight;
                
                ctx.beginPath();
                ctx.moveTo(xPos, 0);
                ctx.lineTo(xPos, mapHeight);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, yPos);
                ctx.lineTo(mapWidth, yPos);
                ctx.stroke();
            }
        }
        
        function drawAxes() {
            ctx.strokeStyle = '#E5E7EB';
            ctx.lineWidth = 2;
            
            const centerX = mapWidth / 2;
            const centerY = mapHeight / 2;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(mapWidth, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, mapHeight);
            ctx.stroke();
        }
        
        function drawAxisLabels() {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const centerX = mapWidth / 2;
            const centerY = mapHeight / 2;
            
            for (let i = 0; i <= 40; i += 10) {
                if (i === 20) continue;
                const value = i - 20;
                
                const xPos = (i / 40) * mapWidth;
                const yPos = mapHeight - (i / 40) * mapHeight;
                
                ctx.fillText(value.toString(), xPos, centerY + 15);
                ctx.fillText(value.toString(), centerX - 15, yPos);
            }
        }
        
        function drawPathLine() {
            const startX = (startPoint.x + 20) / 40 * mapWidth;
            const startY = mapHeight - (startPoint.y + 20) / 40 * mapHeight;
            const endX = (endPoint.x + 20) / 40 * mapWidth;
            const endY = mapHeight - (endPoint.y + 20) / 40 * mapHeight;
            
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#FF6B6B';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            const angle = Math.atan2(endY - startY, endX - startX);
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - 15 * Math.cos(angle - Math.PI/6), endY - 15 * Math.sin(angle - Math.PI/6));
            ctx.lineTo(endX - 15 * Math.cos(angle + Math.PI/6), endY - 15 * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fill();
        }
        
        function drawPoints() {
            if (startPoint) {
                const x = (startPoint.x + 20) / 40 * mapWidth;
                const y = mapHeight - (startPoint.y + 20) / 40 * mapHeight;
                
                ctx.fillStyle = '#10B981';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('S', x, y);
            }
            
            if (endPoint) {
                const x = (endPoint.x + 20) / 40 * mapWidth;
                const y = mapHeight - (endPoint.y + 20) / 40 * mapHeight;
                
                ctx.fillStyle = '#EF4444';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('E', x, y);
            }
        }
        
        function drawMovingObject() {
            if (isSimulationRunning || (startPoint && !isSimulationRunning)) {
                const pos = isSimulationRunning ? objectPosition : startPoint;
                const x = (pos.x + 20) / 40 * mapWidth;
                const y = mapHeight - (pos.y + 20) / 40 * mapHeight;
                
                const gradient = ctx.createRadialGradient(x, y, 5, x, y, 20);
                gradient.addColorStop(0, 'rgba(93, 92, 222, 0.8)');
                gradient.addColorStop(1, 'rgba(93, 92, 222, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, 20, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#5D5CDE';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                if (isSimulationRunning && startPoint && endPoint) {
                    drawVelocityVector(x, y);
                }
            }
        }
        
        function drawVelocityVector(x, y) {
            const elapsedTime = isPaused ? pausedTime / 1000 * timeScale : (performance.now() - startTime) / 1000 * timeScale;
            const currentSpeed = initialSpeed + acceleration * elapsedTime;
            
            if (currentSpeed > 0) {
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                const pathLen = Math.sqrt(dx * dx + dy * dy);
                
                if (pathLen > 0) {
                    const vectorScale = currentSpeed * 2;
                    const vx = (dx / pathLen) * vectorScale;
                    const vy = (dy / pathLen) * vectorScale;
                    
                    const endVecX = x + vx;
                    const endVecY = y - vy;
                    
                    ctx.strokeStyle = '#FF6B6B';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(endVecX, endVecY);
                    ctx.stroke();
                    
                    const angle = Math.atan2(endVecY - y, endVecX - x);
                    ctx.fillStyle = '#FF6B6B';
                    ctx.beginPath();
                    ctx.moveTo(endVecX, endVecY);
                    ctx.lineTo(endVecX - 8 * Math.cos(angle - Math.PI/6), endVecY - 8 * Math.sin(angle - Math.PI/6));
                    ctx.lineTo(endVecX - 8 * Math.cos(angle + Math.PI/6), endVecY - 8 * Math.sin(angle + Math.PI/6));
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }
        
        // ============================================================================
        // APPLICATION INITIALIZATION
        // ============================================================================
        
        init();
    </script>
</body>
</html>
