<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Motion Visualizer</title>
    <!-- TailwindCSS for responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MathJS for mathematical calculations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script>
        // Tailwind configuration with Uber-inspired theme
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#000000',
                        secondary: '#1976D2',
                        accent: '#00BCD4',
                        success: '#4CAF50',
                        warning: '#FF9800',
                        error: '#F44336',
                        surface: '#FFFFFF',
                        background: '#F5F5F5',
                    },
                    boxShadow: {
                        'card': '0 2px 8px rgba(0, 0, 0, 0.1)',
                        'fab': '0 4px 12px rgba(0, 0, 0, 0.15)',
                    }
                }
            }
        }
        
        // Dark mode detection and handling
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
    </script>
</head>
<body class="bg-background dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen overflow-hidden">
    <!-- Uber-style App Layout -->
    <div class="relative w-full h-screen flex flex-col">
        
        <!-- Top App Bar -->
        <div class="relative z-20 bg-surface dark:bg-gray-800 shadow-card">
            <div class="px-4 py-3 flex items-center justify-between">
                <!-- App Title -->
                <div class="flex items-center space-x-3">
                    <div class="w-8 h-8 bg-primary rounded-lg flex items-center justify-center">
                        <div class="w-4 h-4 bg-white rounded-full"></div>
                    </div>
                    <div>
                        <h1 class="text-lg font-semibold text-primary dark:text-white">Physics Motion</h1>
                        <div class="text-xs text-gray-500 dark:text-gray-400" id="status-text">Ready to start</div>
                    </div>
                </div>
                
                <!-- Timer Display -->
                <div class="text-right">
                    <div class="text-xl font-bold text-primary dark:text-white" id="timer-display">0.00s</div>
                    <div class="text-xs text-gray-500 dark:text-gray-400">Time</div>
                </div>
            </div>
        </div>

        <!-- Main Canvas Area -->
        <div class="flex-1 relative">
            <canvas id="motionMap" class="w-full h-full bg-white dark:bg-gray-800 cursor-crosshair touch-manipulation"></canvas>
            
            <!-- Floating Coordinate Display -->
            <div class="absolute top-4 right-4 bg-surface dark:bg-gray-700 px-3 py-2 rounded-lg shadow-card">
                <div class="text-xs font-mono text-gray-600 dark:text-gray-300" id="coordinates">X: 0, Y: 0</div>
            </div>
            
            <!-- Floating Instruction Card -->
            <div class="absolute top-4 left-4 bg-surface dark:bg-gray-700 px-4 py-2 rounded-lg shadow-card max-w-xs">
                <div class="text-sm text-gray-700 dark:text-gray-300" id="instruction-text">
                    Tap to set start point
                </div>
            </div>

            <!-- Scale Selector (Top Center) -->
            <div class="absolute top-4 left-1/2 transform -translate-x-1/2 bg-surface dark:bg-gray-700 rounded-lg shadow-card p-2">
                <select id="grid-scale" class="text-sm border-none bg-transparent text-gray-700 dark:text-gray-300 font-medium focus:outline-none text-base">
                    <option value="10">±5 units</option>
                    <option value="20">±10 units</option>
                    <option value="40" selected>±20 units</option>
                    <option value="100">±50 units</option>
                    <option value="200">±100 units</option>
                    <option value="1000">±500 units</option>
                    <option value="2000">±1000 units</option>
                </select>
            </div>
        </div>

        <!-- Floating Action Buttons -->
        <div class="absolute right-4 bottom-32 flex flex-col space-y-3 z-30">
            <button id="clear-path" class="w-14 h-14 bg-error text-white rounded-full shadow-fab flex items-center justify-center hover:bg-red-600 transition-all">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                </svg>
            </button>
            <button id="reset-motion" class="w-14 h-14 bg-warning text-white rounded-full shadow-fab flex items-center justify-center hover:bg-orange-600 transition-all">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                </svg>
            </button>
        </div>

        <!-- Bottom Sheet - Main Controls -->
        <div class="relative z-20 bg-surface dark:bg-gray-800 rounded-t-3xl shadow-card">
            <!-- Bottom Sheet Handle -->
            <div class="flex justify-center pt-3 pb-2">
                <div class="w-12 h-1 bg-gray-300 dark:bg-gray-600 rounded-full"></div>
            </div>
            
            <div class="px-6 pb-6">
                <!-- Action Buttons Row -->
                <div class="flex space-x-3 mb-6">
                    <button id="start-simulation" class="flex-1 bg-primary dark:bg-white dark:text-black text-white py-4 rounded-xl font-semibold text-base shadow-card hover:bg-gray-800 dark:hover:bg-gray-100 transition-all" disabled>
                        Set Path First
                    </button>
                    <button id="play-pause" class="flex-1 bg-success text-white py-4 rounded-xl font-semibold text-base shadow-card hover:bg-green-600 transition-all hidden">
                        ▶ Play
                    </button>
                </div>

                <!-- Stats Cards -->
                <div class="grid grid-cols-2 gap-3 mb-4">
                    <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-xl">
                        <div class="text-2xl font-bold text-secondary dark:text-blue-400" id="current-speed">0</div>
                        <div class="text-sm text-gray-600 dark:text-gray-400">Speed (m/s)</div>
                    </div>
                    <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-xl">
                        <div class="text-2xl font-bold text-accent dark:text-cyan-400" id="distance-traveled">0</div>
                        <div class="text-sm text-gray-600 dark:text-gray-400">Distance (m)</div>
                    </div>
                    <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-xl">
                        <div class="text-2xl font-bold text-warning dark:text-orange-400" id="current-acceleration">0</div>
                        <div class="text-sm text-gray-600 dark:text-gray-400">Acceleration (m/s²)</div>
                    </div>
                    <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-xl">
                        <div class="text-2xl font-bold text-success dark:text-green-400" id="progress-percent">0%</div>
                        <div class="text-sm text-gray-600 dark:text-gray-400">Progress</div>
                    </div>
                </div>

                <!-- Progress Bar -->
                <div class="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mb-4">
                    <div id="progress-bar" class="bg-primary dark:bg-white h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>

                <!-- Collapsible Settings -->
                <div class="border-t border-gray-200 dark:border-gray-600 pt-4">
                    <button id="settings-toggle" class="flex items-center justify-between w-full text-left text-gray-700 dark:text-gray-300 font-medium mb-3">
                        <span>Physics Settings</span>
                        <svg id="settings-chevron" class="w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>
                    
                    <div id="settings-panel" class="space-y-4">
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Initial Speed (m/s)</label>
                                <input type="number" id="initial-speed" class="w-full px-3 py-2 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg text-gray-900 dark:text-white text-base focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-white" value="10" min="0" max="100" step="0.1">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Acceleration (m/s²)</label>
                                <input type="number" id="acceleration" class="w-full px-3 py-2 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg text-gray-900 dark:text-white text-base focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-white" value="0" min="-20" max="20" step="0.1">
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Time Scale</label>
                            <select id="time-scale" class="w-full px-3 py-2 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg text-gray-900 dark:text-white text-base focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-white">
                                <option value="1">Real-time</option>
                                <option value="0.5">Half-speed</option>
                                <option value="0.1">Slow motion</option>
                                <option value="2">Double-speed</option>
                            </select>
                        </div>
                        
                        <!-- Path Info Card -->
                        <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                            <div class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Path Information</div>
                            <div class="space-y-1 text-sm text-gray-600 dark:text-gray-400">
                                <div class="flex justify-between">
                                    <span>Start:</span>
                                    <span id="start-coords">Not set</span>
                                </div>
                                <div class="flex justify-between">
                                    <span>End:</span>
                                    <span id="end-coords">Not set</span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Distance:</span>
                                    <span id="path-distance">0 m</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Legend (Bottom Left) -->
        <div class="absolute bottom-4 left-4 bg-surface dark:bg-gray-700 p-3 rounded-lg shadow-card z-10">
            <div class="grid grid-cols-2 gap-2 text-xs">
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-success rounded-full"></div>
                    <span class="text-gray-600 dark:text-gray-300">Start</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-error rounded-full"></div>
                    <span class="text-gray-600 dark:text-gray-300">End</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-primary dark:bg-white rounded-full"></div>
                    <span class="text-gray-600 dark:text-gray-300">Object</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-1 bg-secondary rounded"></div>
                    <span class="text-gray-600 dark:text-gray-300">Path</span>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        /**
         * Physics Motion Visualizer - Uber-style Interface
         * Features: Clean mobile app design, bottom sheet controls, floating actions
         */
        
        // ============================================================================
        // DOM ELEMENT REFERENCES
        // ============================================================================
        
        const statusText = document.getElementById('status-text');
        const instructionText = document.getElementById('instruction-text');
        const startCoordsDisplay = document.getElementById('start-coords');
        const endCoordsDisplay = document.getElementById('end-coords');
        const pathDistanceDisplay = document.getElementById('path-distance');
        const clearPathBtn = document.getElementById('clear-path');
        const gridScaleSelect = document.getElementById('grid-scale');
        const initialSpeedInput = document.getElementById('initial-speed');
        const accelerationInput = document.getElementById('acceleration');
        const timeScaleSelect = document.getElementById('time-scale');
        const startSimulationBtn = document.getElementById('start-simulation');
        const settingsToggle = document.getElementById('settings-toggle');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsChevron = document.getElementById('settings-chevron');
        
        const timerDisplay = document.getElementById('timer-display');
        const currentSpeedDisplay = document.getElementById('current-speed');
        const distanceTraveledDisplay = document.getElementById('distance-traveled');
        const currentAccelerationDisplay = document.getElementById('current-acceleration');
        const progressPercent = document.getElementById('progress-percent');
        const playPauseBtn = document.getElementById('play-pause');
        const resetMotionBtn = document.getElementById('reset-motion');
        const progressBar = document.getElementById('progress-bar');
        
        const motionMap = document.getElementById('motionMap');
        const coordinatesDisplay = document.getElementById('coordinates');
        const ctx = motionMap.getContext('2d');
        
        // ============================================================================
        // APPLICATION STATE MANAGEMENT
        // ============================================================================
        
        let startPoint = null;
        let endPoint = null;
        let pathLength = 0;
        let objectPosition = { x: 0, y: 0 };
        
        let isSimulationRunning = false;
        let isPaused = false;
        let startTime = 0;
        let pausedTime = 0;
        let animationFrame = null;
        
        let initialSpeed = 10;
        let acceleration = 0;
        let timeScale = 1;
        let gridScale = 40;
        
        let mapWidth, mapHeight;
        let settingsExpanded = false;
        
        // Touch handling variables
        let touchStartTime = 0;
        let hasMoved = false;
        
        // ============================================================================
        // COORDINATE CONVERSION FUNCTIONS
        // ============================================================================
        
        function screenToGrid(screenX, screenY) {
            const rect = motionMap.getBoundingClientRect();
            const relativeX = (screenX - rect.left) / rect.width;
            const relativeY = (screenY - rect.top) / rect.height;
            
            const x = Math.floor(relativeX * gridScale) - gridScale/2;
            const y = Math.floor((1 - relativeY) * gridScale) - gridScale/2;
            
            return { x, y };
        }
        
        function gridToScreen(gridX, gridY) {
            const relativeX = (gridX + gridScale/2) / gridScale;
            const relativeY = 1 - (gridY + gridScale/2) / gridScale;
            
            const screenX = relativeX * mapWidth;
            const screenY = relativeY * mapHeight;
            
            return { x: screenX, y: screenY };
        }
        
        // ============================================================================
        // EVENT LISTENERS SETUP
        // ============================================================================
        
        clearPathBtn.addEventListener('click', clearPath);
        startSimulationBtn.addEventListener('click', startSimulation);
        playPauseBtn.addEventListener('click', togglePlayPause);
        resetMotionBtn.addEventListener('click', resetMotion);
        settingsToggle.addEventListener('click', toggleSettings);
        
        // Mouse events
        motionMap.addEventListener('click', handleMapClick);
        motionMap.addEventListener('mousemove', updateCoordinates);
        
        // Touch events for mobile
        motionMap.addEventListener('touchstart', handleTouchStart);
        motionMap.addEventListener('touchmove', handleTouchMove);
        motionMap.addEventListener('touchend', handleTouchEnd);
        
        gridScaleSelect.addEventListener('change', updateGridScale);
        initialSpeedInput.addEventListener('input', updatePhysicsParams);
        accelerationInput.addEventListener('input', updatePhysicsParams);
        timeScaleSelect.addEventListener('change', updatePhysicsParams);
        
        window.addEventListener('resize', handleWindowResize);
        
        // ============================================================================
        // UI CONTROL FUNCTIONS
        // ============================================================================
        
        function toggleSettings() {
            settingsExpanded = !settingsExpanded;
            
            if (settingsExpanded) {
                settingsPanel.style.display = 'block';
                settingsChevron.style.transform = 'rotate(180deg)';
            } else {
                settingsPanel.style.display = 'none';
                settingsChevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        function init() {
            handleWindowResize();
            updatePhysicsParams();
            updateGridScale();
            
            // Initially hide settings
            settingsPanel.style.display = 'none';
            
            drawMap();
        }
        
        // ============================================================================
        // RESPONSIVE CANVAS HANDLING
        // ============================================================================
        
        function handleWindowResize() {
            mapWidth = motionMap.offsetWidth;
            mapHeight = motionMap.offsetHeight;
            motionMap.width = mapWidth;
            motionMap.height = mapHeight;
            drawMap();
        }
        
        // ============================================================================
        // TOUCH AND MOBILE INTERACTION HANDLERS
        // ============================================================================
        
        function handleTouchStart(e) {
            e.preventDefault();
            touchStartTime = Date.now();
            hasMoved = false;
            
            if (e.touches.length > 0) {
                updateCoordinates(e.touches[0]);
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            hasMoved = true;
            
            if (e.touches.length > 0) {
                updateCoordinates(e.touches[0]);
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            
            const touchDuration = Date.now() - touchStartTime;
            if (!hasMoved && touchDuration < 500) {
                const touch = e.changedTouches[0];
                if (touch) {
                    handleMapInteraction(touch);
                }
            }
        }
        
        // ============================================================================
        // MAP INTERACTION FUNCTIONS
        // ============================================================================
        
        function handleMapClick(e) {
            handleMapInteraction(e);
        }
        
        function handleMapInteraction(e) {
            if (isSimulationRunning) return;
            
            const gridCoords = screenToGrid(e.clientX, e.clientY);
            const x = gridCoords.x;
            const y = gridCoords.y;
            
            if (!startPoint) {
                startPoint = { x, y };
                startCoordsDisplay.textContent = `(${x}, ${y})`;
                instructionText.textContent = 'Tap to set end point';
                statusText.textContent = 'Setting end point';
                updateUI();
            } else if (!endPoint) {
                endPoint = { x, y };
                endCoordsDisplay.textContent = `(${x}, ${y})`;
                calculatePathLength();
                instructionText.textContent = 'Path ready! Start simulation';
                statusText.textContent = 'Ready to simulate';
                updateUI();
            } else {
                startPoint = { x, y };
                endPoint = null;
                startCoordsDisplay.textContent = `(${x}, ${y})`;
                endCoordsDisplay.textContent = 'Not set';
                pathDistanceDisplay.textContent = '0 m';
                instructionText.textContent = 'Tap to set end point';
                statusText.textContent = 'Setting end point';
                updateUI();
            }
            
            drawMap();
        }
        
        function updateCoordinates(e) {
            const gridCoords = screenToGrid(e.clientX, e.clientY);
            coordinatesDisplay.textContent = `X: ${gridCoords.x}, Y: ${gridCoords.y}`;
        }
        
        // ============================================================================
        // SCALE AND PHYSICS FUNCTIONS
        // ============================================================================
        
        function updateGridScale() {
            gridScale = parseInt(gridScaleSelect.value);
            
            if (startPoint || endPoint) {
                clearPath();
            }
            
            drawMap();
        }
        
        function calculatePathLength() {
            if (startPoint && endPoint) {
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                pathLength = Math.sqrt(dx * dx + dy * dy);
                pathDistanceDisplay.textContent = `${pathLength.toFixed(1)} m`;
            }
        }
        
        function updatePhysicsParams() {
            initialSpeed = parseFloat(initialSpeedInput.value) || 0;
            acceleration = parseFloat(accelerationInput.value) || 0;
            timeScale = parseFloat(timeScaleSelect.value) || 1;
            currentAccelerationDisplay.textContent = acceleration.toFixed(1);
        }
        
        // ============================================================================
        // UI UPDATE FUNCTIONS
        // ============================================================================
        
        function updateUI() {
            const hasPath = startPoint && endPoint;
            startSimulationBtn.disabled = !hasPath;
            startSimulationBtn.textContent = hasPath ? 'Start Simulation' : 'Set Path First';
            
            if (hasPath) {
                startSimulationBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                startSimulationBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }
        
        function clearPath() {
            startPoint = null;
            endPoint = null;
            pathLength = 0;
            startCoordsDisplay.textContent = 'Not set';
            endCoordsDisplay.textContent = 'Not set';
            pathDistanceDisplay.textContent = '0 m';
            instructionText.textContent = 'Tap to set start point';
            statusText.textContent = 'Ready to start';
            updateUI();
            drawMap();
        }
        
        // ============================================================================
        // SIMULATION CONTROL FUNCTIONS
        // ============================================================================
        
        function startSimulation() {
            if (!startPoint || !endPoint) return;
            
            isSimulationRunning = true;
            isPaused = false;
            startTime = performance.now();
            pausedTime = 0;
            objectPosition = { ...startPoint };
            
            startSimulationBtn.style.display = 'none';
            playPauseBtn.style.display = 'block';
            playPauseBtn.textContent = '⏸ Pause';
            statusText.textContent = 'Simulation running';
            instructionText.textContent = 'Object is moving!';
            
            animate();
        }
        
        function togglePlayPause() {
            if (!isSimulationRunning) return;
            
            if (isPaused) {
                isPaused = false;
                startTime = performance.now() - pausedTime;
                playPauseBtn.textContent = '⏸ Pause';
                statusText.textContent = 'Simulation running';
                animate();
            } else {
                isPaused = true;
                pausedTime = performance.now() - startTime;
                playPauseBtn.textContent = '▶ Resume';
                statusText.textContent = 'Simulation paused';
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                }
            }
        }
        
        function resetMotion() {
            isSimulationRunning = false;
            isPaused = false;
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            startSimulationBtn.style.display = 'block';
            playPauseBtn.style.display = 'none';
            playPauseBtn.textContent = '▶ Play';
            
            timerDisplay.textContent = '0.00s';
            currentSpeedDisplay.textContent = '0';
            distanceTraveledDisplay.textContent = '0';
            progressPercent.textContent = '0%';
            progressBar.style.width = '0%';
            
            if (startPoint && endPoint) {
                statusText.textContent = 'Ready to simulate';
                instructionText.textContent = 'Path ready! Start simulation';
            } else {
                statusText.textContent = 'Ready to start';
                instructionText.textContent = 'Tap to set start point';
            }
            
            if (startPoint) {
                objectPosition = { ...startPoint };
            }
            
            drawMap();
        }
        
        // ============================================================================
        // ANIMATION AND PHYSICS SIMULATION
        // ============================================================================
        
        function animate() {
            if (!isSimulationRunning || isPaused) return;
            
            const currentTime = performance.now();
            const elapsedTime = (currentTime - startTime) / 1000 * timeScale;
            
            const currentSpeed = initialSpeed + acceleration * elapsedTime;
            const distanceTraveled = initialSpeed * elapsedTime + 0.5 * acceleration * elapsedTime * elapsedTime;
            
            timerDisplay.textContent = `${elapsedTime.toFixed(2)}s`;
            currentSpeedDisplay.textContent = currentSpeed.toFixed(1);
            distanceTraveledDisplay.textContent = distanceTraveled.toFixed(1);
            
            if (pathLength > 0) {
                const progress = Math.min(distanceTraveled / pathLength, 1);
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                
                objectPosition.x = startPoint.x + dx * progress;
                objectPosition.y = startPoint.y + dy * progress;
                
                progressBar.style.width = `${progress * 100}%`;
                progressPercent.textContent = `${(progress * 100).toFixed(0)}%`;
                
                if (progress >= 1) {
                    isSimulationRunning = false;
                    startSimulationBtn.style.display = 'block';
                    playPauseBtn.style.display = 'none';
                    statusText.textContent = 'Destination reached!';
                    instructionText.textContent = 'Simulation complete!';
                    drawMap();
                    return;
                }
            }
            
            drawMap();
            animationFrame = requestAnimationFrame(animate);
        }
        
        // ============================================================================
        // CANVAS DRAWING FUNCTIONS
        // ============================================================================
        
        function drawMap() {
            ctx.clearRect(0, 0, mapWidth, mapHeight);
            
            drawBackground();
            drawGrid();
            drawAxes();
            drawAxisLabels();
            
            if (startPoint && endPoint) {
                drawPathLine();
            }
            
            drawPoints();
            drawMovingObject();
        }
        
        function drawBackground() {
            // Clean white background for light mode, dark for dark mode
            const isDark = document.documentElement.classList.contains('dark');
            ctx.fillStyle = isDark ? '#1F2937' : '#FFFFFF';
            ctx.fillRect(0, 0, mapWidth, mapHeight);
        }
        
        function drawGrid() {
            const isDark = document.documentElement.classList.contains('dark');
            ctx.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';
            ctx.lineWidth = 1;
            
            let gridStep = 1;
            if (gridScale >= 200) gridStep = 10;
            else if (gridScale >= 100) gridStep = 5;
            else if (gridScale >= 40) gridStep = 2;
            
            const numLines = gridScale / gridStep;
            
            for (let i = 0; i <= numLines; i++) {
                const ratio = i / numLines;
                const xPos = ratio * mapWidth;
                const yPos = ratio * mapHeight;
                
                ctx.beginPath();
                ctx.moveTo(xPos, 0);
                ctx.lineTo(xPos, mapHeight);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, yPos);
                ctx.lineTo(mapWidth, yPos);
                ctx.stroke();
            }
        }
        
        function drawAxes() {
            const isDark = document.documentElement.classList.contains('dark');
            ctx.strokeStyle = isDark ? '#6B7280' : '#9CA3AF';
            ctx.lineWidth = 2;
            
            const centerX = mapWidth / 2;
            const centerY = mapHeight / 2;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(mapWidth, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, mapHeight);
            ctx.stroke();
        }
        
        function drawAxisLabels() {
            const isDark = document.documentElement.classList.contains('dark');
            ctx.fillStyle = isDark ? '#D1D5DB' : '#6B7280';
            ctx.font = '12px system-ui, -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const centerX = mapWidth / 2;
            const centerY = mapHeight / 2;
            const halfScale = gridScale / 2;
            
            let labelStep = 1;
            if (gridScale >= 1000) labelStep = 100;
            else if (gridScale >= 200) labelStep = 20;
            else if (gridScale >= 100) labelStep = 10;
            else if (gridScale >= 40) labelStep = 5;
            
            for (let value = -halfScale; value <= halfScale; value += labelStep) {
                if (value === 0) continue;
                
                const screenPos = gridToScreen(value, 0);
                ctx.fillText(value.toString(), screenPos.x, centerY + 15);
            }
            
            for (let value = -halfScale; value <= halfScale; value += labelStep) {
                if (value === 0) continue;
                
                const screenPos = gridToScreen(0, value);
                ctx.fillText(value.toString(), centerX - 15, screenPos.y);
            }
        }
        
        function drawPathLine() {
            const startScreen = gridToScreen(startPoint.x, startPoint.y);
            const endScreen = gridToScreen(endPoint.x, endPoint.y);
            
            ctx.setLineDash([8, 4]);
            ctx.strokeStyle = '#1976D2';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(startScreen.x, startScreen.y);
            ctx.lineTo(endScreen.x, endScreen.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            const angle = Math.atan2(endScreen.y - startScreen.y, endScreen.x - startScreen.x);
            ctx.fillStyle = '#1976D2';
            ctx.beginPath();
            ctx.moveTo(endScreen.x, endScreen.y);
            ctx.lineTo(endScreen.x - 12 * Math.cos(angle - Math.PI/6), endScreen.y - 12 * Math.sin(angle - Math.PI/6));
            ctx.lineTo(endScreen.x - 12 * Math.cos(angle + Math.PI/6), endScreen.y - 12 * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fill();
        }
        
        function drawPoints() {
            if (startPoint) {
                const screenPos = gridToScreen(startPoint.x, startPoint.y);
                
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 14px system-ui, -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('S', screenPos.x, screenPos.y);
            }
            
            if (endPoint) {
                const screenPos = gridToScreen(endPoint.x, endPoint.y);
                
                ctx.fillStyle = '#F44336';
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 14px system-ui, -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('E', screenPos.x, screenPos.y);
            }
        }
        
        function drawMovingObject() {
            if (isSimulationRunning || (startPoint && !isSimulationRunning)) {
                const pos = isSimulationRunning ? objectPosition : startPoint;
                const screenPos = gridToScreen(pos.x, pos.y);
                const isDark = document.documentElement.classList.contains('dark');
                
                const gradient = ctx.createRadialGradient(screenPos.x, screenPos.y, 5, screenPos.x, screenPos.y, 25);
                gradient.addColorStop(0, isDark ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.1)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = isDark ? '#FFFFFF' : '#000000';
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = isDark ? '#000000' : '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                if (isSimulationRunning && startPoint && endPoint) {
                    drawVelocityVector(screenPos.x, screenPos.y);
                }
            }
        }
        
        function drawVelocityVector(x, y) {
            const elapsedTime = isPaused ? pausedTime / 1000 * timeScale : (performance.now() - startTime) / 1000 * timeScale;
            const currentSpeed = initialSpeed + acceleration * elapsedTime;
            
            if (currentSpeed > 0) {
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                const pathLen = Math.sqrt(dx * dx + dy * dy);
                
                if (pathLen > 0) {
                    const vectorScale = Math.min(currentSpeed * 3, gridScale / 8);
                    const vx = (dx / pathLen) * vectorScale;
                    const vy = (dy / pathLen) * vectorScale;
                    
                    const vectorEnd = gridToScreen(objectPosition.x + vx, objectPosition.y + vy);
                    
                    ctx.strokeStyle = '#00BCD4';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(vectorEnd.x, vectorEnd.y);
                    ctx.stroke();
                    
                    const angle = Math.atan2(vectorEnd.y - y, vectorEnd.x - x);
                    ctx.fillStyle = '#00BCD4';
                    ctx.beginPath();
                    ctx.moveTo(vectorEnd.x, vectorEnd.y);
                    ctx.lineTo(vectorEnd.x - 10 * Math.cos(angle - Math.PI/6), vectorEnd.y - 10 * Math.sin(angle - Math.PI/6));
                    ctx.lineTo(vectorEnd.x - 10 * Math.cos(angle + Math.PI/6), vectorEnd.y - 10 * Math.sin(angle + Math.PI/6));
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }
        
        // ============================================================================
        // APPLICATION INITIALIZATION
        // ============================================================================
        
        init();
    </script>
</body>
</html>
