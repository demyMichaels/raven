<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Motion Visualizer Pro</title>
    <!-- TailwindCSS for responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MathJS for mathematical calculations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script>
        // Tailwind configuration with enhanced theme
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#000000',
                        secondary: '#1976D2',
                        accent: '#00BCD4',
                        success: '#4CAF50',
                        warning: '#FF9800',
                        error: '#F44336',
                        surface: '#FFFFFF',
                        background: '#F5F5F5',
                    },
                    boxShadow: {
                        'card': '0 2px 8px rgba(0, 0, 0, 0.1)',
                        'fab': '0 4px 12px rgba(0, 0, 0, 0.15)',
                    }
                }
            }
        }
        
        // Dark mode detection and handling
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
    </script>
</head>
<body class="bg-background dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen overflow-hidden">
    <!-- Enhanced App Layout -->
    <div class="relative w-full h-screen flex flex-col">
        
        <!-- Top App Bar with Presets -->
        <div class="relative z-20 bg-surface dark:bg-gray-800 shadow-card">
            <div class="px-4 py-3 flex items-center justify-between">
                <!-- App Title -->
                <div class="flex items-center space-x-3">
                    <div class="w-8 h-8 bg-primary rounded-lg flex items-center justify-center">
                        <div class="w-4 h-4 bg-white rounded-full"></div>
                    </div>
                    <div>
                        <h1 class="text-lg font-semibold text-primary dark:text-white">Physics Motion Pro</h1>
                        <div class="text-xs text-gray-500 dark:text-gray-400" id="status-text">Ready to start</div>
                    </div>
                </div>
                
                <!-- Timer & ETA Display -->
                <div class="text-right">
                    <div class="text-xl font-bold text-primary dark:text-white" id="timer-display">0.00s</div>
                    <div class="text-xs text-gray-500 dark:text-gray-400" id="eta-display">ETA: --</div>
                </div>
            </div>
            
            <!-- Physics Presets Bar -->
            <div class="px-4 pb-3">
                <div class="flex space-x-2 overflow-x-auto">
                    <button class="preset-btn px-3 py-1 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded-full text-xs whitespace-nowrap" data-preset="constant">
                        üöó Constant Speed
                    </button>
                    <button class="preset-btn px-3 py-1 bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 rounded-full text-xs whitespace-nowrap" data-preset="acceleration">
                        üöÄ Acceleration
                    </button>
                    <button class="preset-btn px-3 py-1 bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 rounded-full text-xs whitespace-nowrap" data-preset="deceleration">
                        üõë Braking
                    </button>
                    <button class="preset-btn px-3 py-1 bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200 rounded-full text-xs whitespace-nowrap" data-preset="freefall">
                        ü™Ç Free Fall
                    </button>
                    <button class="preset-btn px-3 py-1 bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 rounded-full text-xs whitespace-nowrap" data-preset="pendulum">
                        ‚è±Ô∏è Oscillation
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Canvas Area -->
        <div class="flex-1 relative">
            <canvas id="motionMap" class="w-full h-full bg-white dark:bg-gray-800 cursor-crosshair touch-manipulation"></canvas>
            
            <!-- Enhanced Floating Controls -->
            <div class="absolute top-4 right-4 space-y-2">
                <!-- Coordinate Display -->
                <div class="bg-surface dark:bg-gray-700 px-3 py-2 rounded-lg shadow-card">
                    <div class="text-xs font-mono text-gray-600 dark:text-gray-300" id="coordinates">X: 0, Y: 0</div>
                </div>
                
                <!-- Visual Aids Toggle -->
                <div class="bg-surface dark:bg-gray-700 px-3 py-2 rounded-lg shadow-card">
                    <div class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">Visual Aids</div>
                    <div class="space-y-1">
                        <label class="flex items-center space-x-2 text-xs">
                            <input type="checkbox" id="show-trail" class="w-3 h-3" checked>
                            <span class="text-gray-600 dark:text-gray-300">Motion Trail</span>
                        </label>
                        <label class="flex items-center space-x-2 text-xs">
                            <input type="checkbox" id="show-velocity" class="w-3 h-3" checked>
                            <span class="text-gray-600 dark:text-gray-300">Velocity Vector</span>
                        </label>
                        <label class="flex items-center space-x-2 text-xs">
                            <input type="checkbox" id="show-grid" class="w-3 h-3" checked>
                            <span class="text-gray-600 dark:text-gray-300">Grid Lines</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- Instruction Card -->
            <div class="absolute top-4 left-4 bg-surface dark:bg-gray-700 px-4 py-2 rounded-lg shadow-card max-w-xs">
                <div class="text-sm text-gray-700 dark:text-gray-300" id="instruction-text">
                    Tap to set start point or choose a preset
                </div>
            </div>

            <!-- Scale Selector -->
            <div class="absolute top-4 left-1/2 transform -translate-x-1/2 bg-surface dark:bg-gray-700 rounded-lg shadow-card p-2">
                <select id="grid-scale" class="text-sm border-none bg-transparent text-gray-700 dark:text-gray-300 font-medium focus:outline-none text-base">
                    <option value="10">¬±5 units</option>
                    <option value="20">¬±10 units</option>
                    <option value="40" selected>¬±20 units</option>
                    <option value="100">¬±50 units</option>
                    <option value="200">¬±100 units</option>
                    <option value="1000">¬±500 units</option>
                    <option value="2000">¬±1000 units</option>
                </select>
            </div>

            <!-- Time Scrubber (appears during/after simulation) -->
            <div id="time-scrubber" class="absolute bottom-4 left-4 right-4 bg-surface dark:bg-gray-700 p-3 rounded-lg shadow-card hidden">
                <div class="flex items-center space-x-3">
                    <button id="time-backward" class="w-8 h-8 bg-gray-200 dark:bg-gray-600 rounded-full flex items-center justify-center">‚è™</button>
                    <div class="flex-1">
                        <input type="range" id="time-slider" class="w-full" min="0" max="100" value="0">
                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span>0s</span>
                            <span id="max-time">10s</span>
                        </div>
                    </div>
                    <button id="time-forward" class="w-8 h-8 bg-gray-200 dark:bg-gray-600 rounded-full flex items-center justify-center">‚è©</button>
                </div>
            </div>
        </div>

        <!-- Floating Action Buttons -->
        <div class="absolute right-4 bottom-32 flex flex-col space-y-3 z-30">
            <button id="export-data" class="w-14 h-14 bg-blue-500 text-white rounded-full shadow-fab flex items-center justify-center hover:bg-blue-600 transition-all">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
            </button>
            <button id="clear-path" class="w-14 h-14 bg-error text-white rounded-full shadow-fab flex items-center justify-center hover:bg-red-600 transition-all">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                </svg>
            </button>
            <button id="reset-motion" class="w-14 h-14 bg-warning text-white rounded-full shadow-fab flex items-center justify-center hover:bg-orange-600 transition-all">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                </svg>
            </button>
        </div>

        <!-- Enhanced Bottom Sheet -->
        <div class="relative z-20 bg-surface dark:bg-gray-800 rounded-t-3xl shadow-card">
            <!-- Bottom Sheet Handle -->
            <div class="flex justify-center pt-3 pb-2">
                <div class="w-12 h-1 bg-gray-300 dark:bg-gray-600 rounded-full"></div>
            </div>
            
            <div class="px-6 pb-6">
                <!-- Action Buttons Row -->
                <div class="flex space-x-3 mb-6">
                    <button id="start-simulation" class="flex-1 bg-primary dark:bg-white dark:text-black text-white py-4 rounded-xl font-semibold text-base shadow-card hover:bg-gray-800 dark:hover:bg-gray-100 transition-all" disabled>
                        Set Path First
                    </button>
                    <button id="play-pause" class="flex-1 bg-success text-white py-4 rounded-xl font-semibold text-base shadow-card hover:bg-green-600 transition-all hidden">
                        ‚ñ∂ Play
                    </button>
                </div>

                <!-- Enhanced Stats Cards -->
                <div class="grid grid-cols-2 gap-3 mb-4">
                    <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-xl">
                        <div class="text-2xl font-bold text-secondary dark:text-blue-400" id="current-speed">0</div>
                        <div class="text-sm text-gray-600 dark:text-gray-400">Speed (m/s)</div>
                    </div>
                    <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-xl">
                        <div class="text-2xl font-bold text-accent dark:text-cyan-400" id="distance-traveled">0</div>
                        <div class="text-sm text-gray-600 dark:text-gray-400">Distance (m)</div>
                    </div>
                    <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-xl">
                        <div class="text-2xl font-bold text-warning dark:text-orange-400" id="current-acceleration">0</div>
                        <div class="text-sm text-gray-600 dark:text-gray-400">Acceleration (m/s¬≤)</div>
                    </div>
                    <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-xl">
                        <div class="text-2xl font-bold text-success dark:text-green-400" id="progress-percent">0%</div>
                        <div class="text-sm text-gray-600 dark:text-gray-400">Progress</div>
                    </div>
                </div>

                <!-- Live Graphs Section -->
                <div class="mb-4">
                    <button id="graphs-toggle" class="flex items-center justify-between w-full text-left text-gray-700 dark:text-gray-300 font-medium mb-3">
                        <span>üìä Live Graphs</span>
                        <svg id="graphs-chevron" class="w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>
                    
                    <div id="graphs-panel" class="space-y-3">
                        <div class="bg-gray-50 dark:bg-gray-700 p-3 rounded-xl">
                            <div class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Velocity vs Time</div>
                            <canvas id="velocity-graph" width="280" height="80" class="w-full h-20 bg-white dark:bg-gray-600 rounded"></canvas>
                        </div>
                        <div class="bg-gray-50 dark:bg-gray-700 p-3 rounded-xl">
                            <div class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Distance vs Displacement</div>
                            <div class="flex justify-between text-xs">
                                <div class="text-center">
                                    <div class="text-lg font-bold text-blue-500" id="displacement-value">0</div>
                                    <div class="text-gray-500">Displacement (m)</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-lg font-bold text-orange-500" id="path-length-value">0</div>
                                    <div class="text-gray-500">Path Length (m)</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Progress Bar -->
                <div class="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mb-4">
                    <div id="progress-bar" class="bg-primary dark:bg-white h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>

                <!-- Enhanced Settings -->
                <div class="border-t border-gray-200 dark:border-gray-600 pt-4">
                    <button id="settings-toggle" class="flex items-center justify-between w-full text-left text-gray-700 dark:text-gray-300 font-medium mb-3">
                        <span>‚öôÔ∏è Physics Settings</span>
                        <svg id="settings-chevron" class="w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>
                    
                    <div id="settings-panel" class="space-y-4">
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Initial Speed (m/s)</label>
                                <input type="number" id="initial-speed" class="w-full px-3 py-2 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg text-gray-900 dark:text-white text-base focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-white" value="10" min="0" max="100" step="0.1">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Acceleration (m/s¬≤)</label>
                                <input type="number" id="acceleration" class="w-full px-3 py-2 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg text-gray-900 dark:text-white text-base focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-white" value="0" min="-20" max="20" step="0.1">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Time Scale</label>
                                <select id="time-scale" class="w-full px-3 py-2 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg text-gray-900 dark:text-white text-base focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-white">
                                    <option value="0.25">0.25√ó Slow</option>
                                    <option value="0.5">0.5√ó Half</option>
                                    <option value="1" selected>1√ó Real-time</option>
                                    <option value="2">2√ó Double</option>
                                    <option value="4">4√ó Fast</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Friction (Œ≤)</label>
                                <input type="number" id="friction" class="w-full px-3 py-2 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg text-gray-900 dark:text-white text-base focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-white" value="0" min="0" max="2" step="0.1">
                            </div>
                        </div>
                        
                        <!-- Path Info Card -->
                        <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                            <div class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Path Information</div>
                            <div class="space-y-1 text-sm text-gray-600 dark:text-gray-400">
                                <div class="flex justify-between">
                                    <span>Start:</span>
                                    <span id="start-coords">Not set</span>
                                </div>
                                <div class="flex justify-between">
                                    <span>End:</span>
                                    <span id="end-coords">Not set</span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Distance:</span>
                                    <span id="path-distance">0 m</span>
                                </div>
                                <div class="flex justify-between">
                                    <span>ETA:</span>
                                    <span id="eta-value">-- s</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Enhanced Legend -->
        <div class="absolute bottom-4 left-4 bg-surface dark:bg-gray-700 p-3 rounded-lg shadow-card z-10">
            <div class="grid grid-cols-2 gap-2 text-xs">
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-success rounded-full"></div>
                    <span class="text-gray-600 dark:text-gray-300">Start</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-error rounded-full"></div>
                    <span class="text-gray-600 dark:text-gray-300">End</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-primary dark:bg-white rounded-full"></div>
                    <span class="text-gray-600 dark:text-gray-300">Object</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-1 bg-secondary rounded"></div>
                    <span class="text-gray-600 dark:text-gray-300">Path</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-1 bg-accent rounded opacity-60"></div>
                    <span class="text-gray-600 dark:text-gray-300">Trail</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-1 bg-orange-500 rounded"></div>
                    <span class="text-gray-600 dark:text-gray-300">Vector</span>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        /**
         * Physics Motion Visualizer Pro - Enhanced Uber-style Interface
         * Features: Motion trails, live graphs, physics presets, time scrubber, data export
         */
        
        // ============================================================================
        // DOM ELEMENT REFERENCES
        // ============================================================================
        
        const statusText = document.getElementById('status-text');
        const instructionText = document.getElementById('instruction-text');
        const startCoordsDisplay = document.getElementById('start-coords');
        const endCoordsDisplay = document.getElementById('end-coords');
        const pathDistanceDisplay = document.getElementById('path-distance');
        const etaDisplay = document.getElementById('eta-display');
        const etaValue = document.getElementById('eta-value');
        
        const clearPathBtn = document.getElementById('clear-path');
        const exportDataBtn = document.getElementById('export-data');
        const gridScaleSelect = document.getElementById('grid-scale');
        const initialSpeedInput = document.getElementById('initial-speed');
        const accelerationInput = document.getElementById('acceleration');
        const frictionInput = document.getElementById('friction');
        const timeScaleSelect = document.getElementById('time-scale');
        const startSimulationBtn = document.getElementById('start-simulation');
        
        const settingsToggle = document.getElementById('settings-toggle');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsChevron = document.getElementById('settings-chevron');
        
        const graphsToggle = document.getElementById('graphs-toggle');
        const graphsPanel = document.getElementById('graphs-panel');
        const graphsChevron = document.getElementById('graphs-chevron');
        
        const timerDisplay = document.getElementById('timer-display');
        const currentSpeedDisplay = document.getElementById('current-speed');
        const distanceTraveledDisplay = document.getElementById('distance-traveled');
        const currentAccelerationDisplay = document.getElementById('current-acceleration');
        const progressPercent = document.getElementById('progress-percent');
        const playPauseBtn = document.getElementById('play-pause');
        const resetMotionBtn = document.getElementById('reset-motion');
        const progressBar = document.getElementById('progress-bar');
        
        const motionMap = document.getElementById('motionMap');
        const coordinatesDisplay = document.getElementById('coordinates');
        const ctx = motionMap.getContext('2d');
        
        // Enhanced controls
        const timeScrubber = document.getElementById('time-scrubber');
        const timeSlider = document.getElementById('time-slider');
        const timeBackward = document.getElementById('time-backward');
        const timeForward = document.getElementById('time-forward');
        const maxTimeDisplay = document.getElementById('max-time');
        
        const showTrail = document.getElementById('show-trail');
        const showVelocity = document.getElementById('show-velocity');
        const showGrid = document.getElementById('show-grid');
        
        // Graph canvases
        const velocityGraph = document.getElementById('velocity-graph');
        const velocityCtx = velocityGraph.getContext('2d');
        
        const displacementValue = document.getElementById('displacement-value');
        const pathLengthValue = document.getElementById('path-length-value');
        
        // ============================================================================
        // ENHANCED STATE MANAGEMENT
        // ============================================================================
        
        let startPoint = null;
        let endPoint = null;
        let pathLength = 0;
        let objectPosition = { x: 0, y: 0 };
        
        let isSimulationRunning = false;
        let isPaused = false;
        let startTime = 0;
        let pausedTime = 0;
        let animationFrame = null;
        
        let initialSpeed = 10;
        let acceleration = 0;
        let friction = 0;
        let timeScale = 1;
        let gridScale = 40;
        
        let mapWidth, mapHeight;
        let settingsExpanded = false;
        let graphsExpanded = false;
        
        // Enhanced features
        let motionTrail = [];
        let velocityData = [];
        let simulationData = [];
        let maxRecordedTime = 0;
        let isReplaying = false;
        
        // Touch handling variables
        let touchStartTime = 0;
        let hasMoved = false;
        
        // Physics presets
        const physicsPresets = {
            constant: { speed: 15, acceleration: 0, friction: 0, description: "Uniform motion" },
            acceleration: { speed: 5, acceleration: 3, friction: 0, description: "Constant acceleration" },
            deceleration: { speed: 25, acceleration: -2, friction: 0, description: "Constant deceleration" },
            freefall: { speed: 0, acceleration: 9.8, friction: 0, description: "Free fall motion" },
            pendulum: { speed: 0, acceleration: 0, friction: 0.1, description: "Oscillatory motion" }
        };
        
        // ============================================================================
        // INITIALIZATION AND EVENT LISTENERS
        // ============================================================================
        
        function init() {
            handleWindowResize();
            updatePhysicsParams();
            updateGridScale();
            
            // Initially hide collapsible sections
            settingsPanel.style.display = 'none';
            graphsPanel.style.display = 'none';
            
            setupEventListeners();
            drawMap();
        }
        
        function setupEventListeners() {
            // Existing listeners
            clearPathBtn.addEventListener('click', clearPath);
            exportDataBtn.addEventListener('click', exportData);
            startSimulationBtn.addEventListener('click', startSimulation);
            playPauseBtn.addEventListener('click', togglePlayPause);
            resetMotionBtn.addEventListener('click', resetMotion);
            settingsToggle.addEventListener('click', () => toggleSection('settings'));
            graphsToggle.addEventListener('click', () => toggleSection('graphs'));
            
            // Map interactions
            motionMap.addEventListener('click', handleMapClick);
            motionMap.addEventListener('mousemove', updateCoordinates);
            motionMap.addEventListener('touchstart', handleTouchStart);
            motionMap.addEventListener('touchmove', handleTouchMove);
            motionMap.addEventListener('touchend', handleTouchEnd);
            
            // Controls
            gridScaleSelect.addEventListener('change', updateGridScale);
            initialSpeedInput.addEventListener('input', updatePhysicsParams);
            accelerationInput.addEventListener('input', updatePhysicsParams);
            frictionInput.addEventListener('input', updatePhysicsParams);
            timeScaleSelect.addEventListener('change', updatePhysicsParams);
            
            // Time scrubber
            timeSlider.addEventListener('input', handleTimeSlider);
            timeBackward.addEventListener('click', () => scrubTime(-1));
            timeForward.addEventListener('click', () => scrubTime(1));
            
            // Visual aids
            showTrail.addEventListener('change', drawMap);
            showVelocity.addEventListener('change', drawMap);
            showGrid.addEventListener('change', drawMap);
            
            // Physics presets
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => applyPreset(btn.dataset.preset));
            });
            
            window.addEventListener('resize', handleWindowResize);
        }
        
        // ============================================================================
        // ENHANCED UI FUNCTIONS
        // ============================================================================
        
        function toggleSection(section) {
            if (section === 'settings') {
                settingsExpanded = !settingsExpanded;
                settingsPanel.style.display = settingsExpanded ? 'block' : 'none';
                settingsChevron.style.transform = settingsExpanded ? 'rotate(180deg)' : 'rotate(0deg)';
            } else if (section === 'graphs') {
                graphsExpanded = !graphsExpanded;
                graphsPanel.style.display = graphsExpanded ? 'block' : 'none';
                graphsChevron.style.transform = graphsExpanded ? 'rotate(180deg)' : 'rotate(0deg)';
            }
        }
        
        function applyPreset(presetName) {
            const preset = physicsPresets[presetName];
            if (!preset) return;
            
            // Clear existing path
            clearPath();
            
            // Set preset values
            initialSpeedInput.value = preset.speed;
            accelerationInput.value = preset.acceleration;
            frictionInput.value = preset.friction;
            updatePhysicsParams();
            
            // Set a default path based on preset
            if (presetName === 'freefall') {
                startPoint = { x: 0, y: 15 };
                endPoint = { x: 0, y: -15 };
            } else if (presetName === 'pendulum') {
                startPoint = { x: -10, y: 10 };
                endPoint = { x: 10, y: 10 };
            } else {
                startPoint = { x: -15, y: 0 };
                endPoint = { x: 15, y: 0 };
            }
            
            updatePathInfo();
            calculateETA();
            updateUI();
            drawMap();
            
            instructionText.textContent = `${preset.description} preset applied!`;
            statusText.textContent = 'Preset ready';
        }
        
        function updatePathInfo() {
            if (startPoint && endPoint) {
                startCoordsDisplay.textContent = `(${startPoint.x}, ${startPoint.y})`;
                endCoordsDisplay.textContent = `(${endPoint.x}, ${endPoint.y})`;
                calculatePathLength();
            }
        }
        
        function calculateETA() {
            if (startPoint && endPoint && initialSpeed > 0) {
                const avgSpeed = acceleration !== 0 ? 
                    (initialSpeed + Math.sqrt(initialSpeed * initialSpeed + 2 * acceleration * pathLength)) / 2 :
                    initialSpeed;
                
                const eta = pathLength / avgSpeed;
                etaDisplay.textContent = `ETA: ${eta.toFixed(1)}s`;
                etaValue.textContent = `${eta.toFixed(1)} s`;
            } else {
                etaDisplay.textContent = 'ETA: --';
                etaValue.textContent = '-- s';
            }
        }
        
        // ============================================================================
        // ENHANCED SIMULATION FUNCTIONS
        // ============================================================================
        
        function startSimulation() {
            if (!startPoint || !endPoint) return;
            
            isSimulationRunning = true;
            isPaused = false;
            isReplaying = false;
            startTime = performance.now();
            pausedTime = 0;
            objectPosition = { ...startPoint };
            
            // Reset data arrays
            motionTrail = [{ ...startPoint }];
            velocityData = [];
            simulationData = [];
            maxRecordedTime = 0;
            
            startSimulationBtn.style.display = 'none';
            playPauseBtn.style.display = 'block';
            playPauseBtn.textContent = '‚è∏ Pause';
            statusText.textContent = 'Simulation running';
            instructionText.textContent = 'Object is moving!';
            
            timeScrubber.classList.remove('hidden');
            
            animate();
        }
        
        function animate() {
            if (!isSimulationRunning || isPaused || isReplaying) return;
            
            const currentTime = performance.now();
            const elapsedTime = (currentTime - startTime) / 1000 * timeScale;
            
            // Enhanced physics with friction
            const frictionForce = friction * Math.sign(initialSpeed + acceleration * elapsedTime);
            const effectiveAcceleration = acceleration - frictionForce;
            
            const currentSpeed = Math.max(0, initialSpeed + effectiveAcceleration * elapsedTime);
            const distanceTraveled = initialSpeed * elapsedTime + 0.5 * effectiveAcceleration * elapsedTime * elapsedTime;
            
            // Record data
            const dataPoint = {
                time: elapsedTime,
                speed: currentSpeed,
                distance: distanceTraveled,
                acceleration: effectiveAcceleration,
                position: { ...objectPosition }
            };
            simulationData.push(dataPoint);
            velocityData.push({ time: elapsedTime, velocity: currentSpeed });
            
            // Update displays
            timerDisplay.textContent = `${elapsedTime.toFixed(2)}s`;
            currentSpeedDisplay.textContent = currentSpeed.toFixed(1);
            distanceTraveledDisplay.textContent = distanceTraveled.toFixed(1);
            currentAccelerationDisplay.textContent = effectiveAcceleration.toFixed(1);
            
            // Calculate displacement
            const displacement = Math.sqrt(
                Math.pow(objectPosition.x - startPoint.x, 2) + 
                Math.pow(objectPosition.y - startPoint.y, 2)
            );
            displacementValue.textContent = displacement.toFixed(1);
            pathLengthValue.textContent = distanceTraveled.toFixed(1);
            
            if (pathLength > 0) {
                const progress = Math.min(distanceTraveled / pathLength, 1);
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                
                objectPosition.x = startPoint.x + dx * progress;
                objectPosition.y = startPoint.y + dy * progress;
                
                // Add to trail
                if (motionTrail.length === 0 || 
                    Math.abs(objectPosition.x - motionTrail[motionTrail.length - 1].x) > 0.1 ||
                    Math.abs(objectPosition.y - motionTrail[motionTrail.length - 1].y) > 0.1) {
                    motionTrail.push({ ...objectPosition });
                }
                
                progressBar.style.width = `${progress * 100}%`;
                progressPercent.textContent = `${(progress * 100).toFixed(0)}%`;
                
                // Update time scrubber
                maxRecordedTime = elapsedTime;
                timeSlider.max = maxRecordedTime * 100;
                timeSlider.value = maxRecordedTime * 100;
                maxTimeDisplay.textContent = `${maxRecordedTime.toFixed(1)}s`;
                
                if (progress >= 1 || currentSpeed <= 0.01) {
                    completeSimulation();
                    return;
                }
            }
            
            updateGraphs();
            drawMap();
            animationFrame = requestAnimationFrame(animate);
        }
        
        function completeSimulation() {
            isSimulationRunning = false;
            startSimulationBtn.style.display = 'block';
            playPauseBtn.style.display = 'none';
            statusText.textContent = 'Simulation complete!';
            instructionText.textContent = 'Use time scrubber to review';
            drawMap();
        }
        
        // ============================================================================
        // TIME SCRUBBER FUNCTIONS
        // ============================================================================
        
        function handleTimeSlider() {
            if (simulationData.length === 0) return;
            
            const sliderValue = parseFloat(timeSlider.value);
            const targetTime = sliderValue / 100;
            
            replayToTime(targetTime);
        }
        
        function scrubTime(direction) {
            const currentValue = parseFloat(timeSlider.value);
            const step = maxRecordedTime * 5; // 5% steps
            const newValue = Math.max(0, Math.min(maxRecordedTime * 100, currentValue + direction * step));
            
            timeSlider.value = newValue;
            handleTimeSlider();
        }
        
        function replayToTime(targetTime) {
            if (simulationData.length === 0) return;
            
            isReplaying = true;
            
            // Find the closest data point
            let closestIndex = 0;
            for (let i = 0; i < simulationData.length; i++) {
                if (Math.abs(simulationData[i].time - targetTime) < Math.abs(simulationData[closestIndex].time - targetTime)) {
                    closestIndex = i;
                }
            }
            
            const dataPoint = simulationData[closestIndex];
            
            // Update displays
            timerDisplay.textContent = `${dataPoint.time.toFixed(2)}s`;
            currentSpeedDisplay.textContent = dataPoint.speed.toFixed(1);
            distanceTraveledDisplay.textContent = dataPoint.distance.toFixed(1);
            currentAccelerationDisplay.textContent = dataPoint.acceleration.toFixed(1);
            
            // Update object position
            objectPosition = { ...dataPoint.position };
            
            // Update progress
            const progress = Math.min(dataPoint.distance / pathLength, 1);
            progressBar.style.width = `${progress * 100}%`;
            progressPercent.textContent = `${(progress * 100).toFixed(0)}%`;
            
            // Update trail up to this point
            motionTrail = [];
            for (let i = 0; i <= closestIndex && i < simulationData.length; i += Math.max(1, Math.floor(simulationData.length / 50))) {
                motionTrail.push({ ...simulationData[i].position });
            }
            
            updateGraphs(closestIndex);
            drawMap();
        }
        
        // ============================================================================
        // GRAPH FUNCTIONS
        // ============================================================================
        
        function updateGraphs(maxIndex = -1) {
            drawVelocityGraph(maxIndex);
        }
        
        function drawVelocityGraph(maxIndex = -1) {
            const canvas = velocityGraph;
            const ctx = velocityCtx;
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            if (velocityData.length < 2) return;
            
            const isDark = document.documentElement.classList.contains('dark');
            const dataToShow = maxIndex >= 0 ? velocityData.slice(0, maxIndex + 1) : velocityData;
            
            // Find max values for scaling
            const maxTime = Math.max(...dataToShow.map(d => d.time));
            const maxVelocity = Math.max(...dataToShow.map(d => d.velocity));
            const minVelocity = Math.min(...dataToShow.map(d => d.velocity));
            
            if (maxTime === 0 || maxVelocity === minVelocity) return;
            
            // Draw grid
            ctx.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            for (let i = 0; i <= 4; i++) {
                const x = (i / 4) * width;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Draw velocity curve
            ctx.strokeStyle = '#1976D2';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < dataToShow.length; i++) {
                const x = (dataToShow[i].time / maxTime) * width;
                const y = height - ((dataToShow[i].velocity - minVelocity) / (maxVelocity - minVelocity)) * height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Draw labels
            ctx.fillStyle = isDark ? '#D1D5DB' : '#6B7280';
            ctx.font = '10px system-ui';
            ctx.textAlign = 'right';
            ctx.fillText(`${maxVelocity.toFixed(1)}`, width - 2, 12);
            ctx.fillText(`${minVelocity.toFixed(1)}`, width - 2, height - 2);
            ctx.textAlign = 'center';
            ctx.fillText(`${maxTime.toFixed(1)}s`, width - 10, height - 2);
        }
        
        // ============================================================================
        // DATA EXPORT FUNCTION
        // ============================================================================
        
        function exportData() {
            if (simulationData.length === 0) {
                showNotification('No simulation data to export');
                return;
            }
            
            let csv = 'Time (s),Position X (m),Position Y (m),Speed (m/s),Acceleration (m/s¬≤),Distance Traveled (m)\n';
            
            simulationData.forEach(data => {
                csv += `${data.time.toFixed(3)},${data.position.x.toFixed(3)},${data.position.y.toFixed(3)},${data.speed.toFixed(3)},${data.acceleration.toFixed(3)},${data.distance.toFixed(3)}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `physics_motion_data_${new Date().toISOString().slice(0, 10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('Data exported successfully!');
        }
        
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-success text-white px-4 py-2 rounded-lg shadow-fab z-50';
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // ============================================================================
        // ENHANCED DRAWING FUNCTIONS
        // ============================================================================
        
        function drawMap() {
            ctx.clearRect(0, 0, mapWidth, mapHeight);
            
            drawBackground();
            if (showGrid.checked) {
                drawGrid();
                drawAxes();
                drawAxisLabels();
            }
            
            if (startPoint && endPoint) {
                drawPathLine();
            }
            
            if (showTrail.checked && motionTrail.length > 1) {
                drawMotionTrail();
            }
            
            drawPoints();
            drawMovingObject();
        }
        
        function drawMotionTrail() {
            if (motionTrail.length < 2) return;
            
            ctx.strokeStyle = '#00BCD4';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.6;
            
            ctx.beginPath();
            for (let i = 0; i < motionTrail.length; i++) {
                const screenPos = gridToScreen(motionTrail[i].x, motionTrail[i].y);
                if (i === 0) {
                    ctx.moveTo(screenPos.x, screenPos.y);
                } else {
                    ctx.lineTo(screenPos.x, screenPos.y);
                }
            }
            ctx.stroke();
            
            // Draw trail dots
            ctx.fillStyle = '#00BCD4';
            for (let i = 0; i < motionTrail.length; i += Math.max(1, Math.floor(motionTrail.length / 20))) {
                const screenPos = gridToScreen(motionTrail[i].x, motionTrail[i].y);
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.globalAlpha = 1;
        }
        
        function drawMovingObject() {
            if (isSimulationRunning || isReplaying || (startPoint && !isSimulationRunning)) {
                const pos = (isSimulationRunning || isReplaying) ? objectPosition : startPoint;
                const screenPos = gridToScreen(pos.x, pos.y);
                const isDark = document.documentElement.classList.contains('dark');
                
                // Enhanced object with glow effect
                const gradient = ctx.createRadialGradient(screenPos.x, screenPos.y, 5, screenPos.x, screenPos.y, 25);
                gradient.addColorStop(0, isDark ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.1)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = isDark ? '#FFFFFF' : '#000000';
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = isDark ? '#000000' : '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                if (showVelocity.checked && (isSimulationRunning || isReplaying) && startPoint && endPoint) {
                    drawVelocityVector(screenPos.x, screenPos.y);
                }
            }
        }
        
        function drawVelocityVector(x, y) {
            const currentData = simulationData[simulationData.length - 1];
            if (!currentData || currentData.speed <= 0) return;
            
            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;
            const pathLen = Math.sqrt(dx * dx + dy * dy);
            
            if (pathLen > 0) {
                const vectorScale = Math.min(currentData.speed * 3, gridScale / 8);
                const vx = (dx / pathLen) * vectorScale;
                const vy = (dy / pathLen) * vectorScale;
                
                const vectorEnd = gridToScreen(objectPosition.x + vx, objectPosition.y + vy);
                
                ctx.strokeStyle = '#FF9800';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(vectorEnd.x, vectorEnd.y);
                ctx.stroke();
                
                // Arrow head
                const angle = Math.atan2(vectorEnd.y - y, vectorEnd.x - x);
                ctx.fillStyle = '#FF9800';
                ctx.beginPath();
                ctx.moveTo(vectorEnd.x, vectorEnd.y);
                ctx.lineTo(vectorEnd.x - 10 * Math.cos(angle - Math.PI/6), vectorEnd.y - 10 * Math.sin(angle - Math.PI/6));
                ctx.lineTo(vectorEnd.x - 10 * Math.cos(angle + Math.PI/6), vectorEnd.y - 10 * Math.sin(angle + Math.PI/6));
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // ============================================================================
        // UTILITY FUNCTIONS (keeping existing ones)
        // ============================================================================
        
        function screenToGrid(screenX, screenY) {
            const rect = motionMap.getBoundingClientRect();
            const relativeX = (screenX - rect.left) / rect.width;
            const relativeY = (screenY - rect.top) / rect.height;
            
            const x = Math.floor(relativeX * gridScale) - gridScale/2;
            const y = Math.floor((1 - relativeY) * gridScale) - gridScale/2;
            
            return { x, y };
        }
        
        function gridToScreen(gridX, gridY) {
            const relativeX = (gridX + gridScale/2) / gridScale;
            const relativeY = 1 - (gridY + gridScale/2) / gridScale;
            
            const screenX = relativeX * mapWidth;
            const screenY = relativeY * mapHeight;
            
            return { x: screenX, y: screenY };
        }
        
        function handleWindowResize() {
            mapWidth = motionMap.offsetWidth;
            mapHeight = motionMap.offsetHeight;
            motionMap.width = mapWidth;
            motionMap.height = mapHeight;
            drawMap();
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            touchStartTime = Date.now();
            hasMoved = false;
            
            if (e.touches.length > 0) {
                updateCoordinates(e.touches[0]);
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            hasMoved = true;
            
            if (e.touches.length > 0) {
                updateCoordinates(e.touches[0]);
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            
            const touchDuration = Date.now() - touchStartTime;
            if (!hasMoved && touchDuration < 500) {
                const touch = e.changedTouches[0];
                if (touch) {
                    handleMapInteraction(touch);
                }
            }
        }
        
        function handleMapClick(e) {
            handleMapInteraction(e);
        }
        
        function handleMapInteraction(e) {
            if (isSimulationRunning) return;
            
            const gridCoords = screenToGrid(e.clientX, e.clientY);
            const x = gridCoords.x;
            const y = gridCoords.y;
            
            if (!startPoint) {
                startPoint = { x, y };
                updatePathInfo();
                instructionText.textContent = 'Tap to set end point';
                statusText.textContent = 'Setting end point';
                updateUI();
            } else if (!endPoint) {
                endPoint = { x, y };
                updatePathInfo();
                calculateETA();
                instructionText.textContent = 'Path ready! Start simulation';
                statusText.textContent = 'Ready to simulate';
                updateUI();
            } else {
                startPoint = { x, y };
                endPoint = null;
                startCoordsDisplay.textContent = `(${x}, ${y})`;
                endCoordsDisplay.textContent = 'Not set';
                pathDistanceDisplay.textContent = '0 m';
                etaDisplay.textContent = 'ETA: --';
                etaValue.textContent = '-- s';
                instructionText.textContent = 'Tap to set end point';
                statusText.textContent = 'Setting end point';
                updateUI();
            }
            
            drawMap();
        }
        
        function updateCoordinates(e) {
            const gridCoords = screenToGrid(e.clientX, e.clientY);
            coordinatesDisplay.textContent = `X: ${gridCoords.x}, Y: ${gridCoords.y}`;
        }
        
        function updateGridScale() {
            gridScale = parseInt(gridScaleSelect.value);
            
            if (startPoint || endPoint) {
                clearPath();
            }
            
            drawMap();
        }
        
        function calculatePathLength() {
            if (startPoint && endPoint) {
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                pathLength = Math.sqrt(dx * dx + dy * dy);
                pathDistanceDisplay.textContent = `${pathLength.toFixed(1)} m`;
            }
        }
        
        function updatePhysicsParams() {
            initialSpeed = parseFloat(initialSpeedInput.value) || 0;
            acceleration = parseFloat(accelerationInput.value) || 0;
            friction = parseFloat(frictionInput.value) || 0;
            timeScale = parseFloat(timeScaleSelect.value) || 1;
            currentAccelerationDisplay.textContent = acceleration.toFixed(1);
            calculateETA();
        }
        
        function updateUI() {
            const hasPath = startPoint && endPoint;
            startSimulationBtn.disabled = !hasPath;
            startSimulationBtn.textContent = hasPath ? 'Start Simulation' : 'Set Path First';
            
            if (hasPath) {
                startSimulationBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                startSimulationBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }
        
        function clearPath() {
            startPoint = null;
            endPoint = null;
            pathLength = 0;
            motionTrail = [];
            velocityData = [];
            simulationData = [];
            
            startCoordsDisplay.textContent = 'Not set';
            endCoordsDisplay.textContent = 'Not set';
            pathDistanceDisplay.textContent = '0 m';
            etaDisplay.textContent = 'ETA: --';
            etaValue.textContent = '-- s';
            displacementValue.textContent = '0';
            pathLengthValue.textContent = '0';
            
            instructionText.textContent = 'Tap to set start point or choose a preset';
            statusText.textContent = 'Ready to start';
            
            timeScrubber.classList.add('hidden');
            updateUI();
            drawMap();
        }
        
        function togglePlayPause() {
            if (!isSimulationRunning) return;
            
            if (isPaused) {
                isPaused = false;
                startTime = performance.now() - pausedTime;
                playPauseBtn.textContent = '‚è∏ Pause';
                statusText.textContent = 'Simulation running';
                animate();
            } else {
                isPaused = true;
                pausedTime = performance.now() - startTime;
                playPauseBtn.textContent = '‚ñ∂ Resume';
                statusText.textContent = 'Simulation paused';
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                }
            }
        }
        
        function resetMotion() {
            isSimulationRunning = false;
            isPaused = false;
            isReplaying = false;
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            startSimulationBtn.style.display = 'block';
            playPauseBtn.style.display = 'none';
            playPauseBtn.textContent = '‚ñ∂ Play';
            
            timerDisplay.textContent = '0.00s';
            currentSpeedDisplay.textContent = '0';
            distanceTraveledDisplay.textContent = '0';
            progressPercent.textContent = '0%';
            progressBar.style.width = '0%';
            displacementValue.textContent = '0';
            pathLengthValue.textContent = '0';
            
            // Clear graphs
            velocityCtx.clearRect(0, 0, velocityGraph.width, velocityGraph.height);
            
            if (startPoint && endPoint) {
                statusText.textContent = 'Ready to simulate';
                instructionText.textContent = 'Path ready! Start simulation';
            } else {
                statusText.textContent = 'Ready to start';
                instructionText.textContent = 'Tap to set start point or choose a preset';
            }
            
            if (startPoint) {
                objectPosition = { ...startPoint };
            }
            
            motionTrail = [];
            velocityData = [];
            simulationData = [];
            
            drawMap();
        }
        
        // Enhanced drawing functions (keeping existing ones like drawBackground, drawGrid, etc.)
        function drawBackground() {
            const isDark = document.documentElement.classList.contains('dark');
            ctx.fillStyle = isDark ? '#1F2937' : '#FFFFFF';
            ctx.fillRect(0, 0, mapWidth, mapHeight);
        }
        
        function drawGrid() {
            const isDark = document.documentElement.classList.contains('dark');
            ctx.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';
            ctx.lineWidth = 1;
            
            let gridStep = 1;
            if (gridScale >= 200) gridStep = 10;
            else if (gridScale >= 100) gridStep = 5;
            else if (gridScale >= 40) gridStep = 2;
            
            const numLines = gridScale / gridStep;
            
            for (let i = 0; i <= numLines; i++) {
                const ratio = i / numLines;
                const xPos = ratio * mapWidth;
                const yPos = ratio * mapHeight;
                
                ctx.beginPath();
                ctx.moveTo(xPos, 0);
                ctx.lineTo(xPos, mapHeight);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, yPos);
                ctx.lineTo(mapWidth, yPos);
                ctx.stroke();
            }
        }
        
        function drawAxes() {
            const isDark = document.documentElement.classList.contains('dark');
            ctx.strokeStyle = isDark ? '#6B7280' : '#9CA3AF';
            ctx.lineWidth = 2;
            
            const centerX = mapWidth / 2;
            const centerY = mapHeight / 2;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(mapWidth, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, mapHeight);
            ctx.stroke();
        }
        
        function drawAxisLabels() {
            const isDark = document.documentElement.classList.contains('dark');
            ctx.fillStyle = isDark ? '#D1D5DB' : '#6B7280';
            ctx.font = '12px system-ui, -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const centerX = mapWidth / 2;
            const centerY = mapHeight / 2;
            const halfScale = gridScale / 2;
            
            let labelStep = 1;
            if (gridScale >= 1000) labelStep = 100;
            else if (gridScale >= 200) labelStep = 20;
            else if (gridScale >= 100) labelStep = 10;
            else if (gridScale >= 40) labelStep = 5;
            
            for (let value = -halfScale; value <= halfScale; value += labelStep) {
                if (value === 0) continue;
                
                const screenPos = gridToScreen(value, 0);
                ctx.fillText(value.toString(), screenPos.x, centerY + 15);
            }
            
            for (let value = -halfScale; value <= halfScale; value += labelStep) {
                if (value === 0) continue;
                
                const screenPos = gridToScreen(0, value);
                ctx.fillText(value.toString(), centerX - 15, screenPos.y);
            }
        }
        
        function drawPathLine() {
            const startScreen = gridToScreen(startPoint.x, startPoint.y);
            const endScreen = gridToScreen(endPoint.x, endPoint.y);
            
            ctx.setLineDash([8, 4]);
            ctx.strokeStyle = '#1976D2';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(startScreen.x, startScreen.y);
            ctx.lineTo(endScreen.x, endScreen.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            const angle = Math.atan2(endScreen.y - startScreen.y, endScreen.x - startScreen.x);
            ctx.fillStyle = '#1976D2';
            ctx.beginPath();
            ctx.moveTo(endScreen.x, endScreen.y);
            ctx.lineTo(endScreen.x - 12 * Math.cos(angle - Math.PI/6), endScreen.y - 12 * Math.sin(angle - Math.PI/6));
            ctx.lineTo(endScreen.x - 12 * Math.cos(angle + Math.PI/6), endScreen.y - 12 * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fill();
        }
        
        function drawPoints() {
            if (startPoint) {
                const screenPos = gridToScreen(startPoint.x, startPoint.y);
                
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 14px system-ui, -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('S', screenPos.x, screenPos.y);
            }
            
            if (endPoint) {
                const screenPos = gridToScreen(endPoint.x, endPoint.y);
                
                ctx.fillStyle = '#F44336';
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 14px system-ui, -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('E', screenPos.x, screenPos.y);
            }
        }
        
        // ============================================================================
        // APPLICATION INITIALIZATION
        // ============================================================================
        
        init();
    </script>
</body>
</html>
