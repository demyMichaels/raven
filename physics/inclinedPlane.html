<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Lab Simulator</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600;700&family=Source+Sans+3:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0f1419;
            --bg-secondary: #1a2332;
            --bg-card: #1e2a3a;
            --bg-simulation: #0a0f14;
            --text-primary: #e8edf4;
            --text-secondary: #8899a6;
            --accent-primary: #ff6b35;
            --accent-secondary: #f7c548;
            --accent-tertiary: #00d4aa;
            --border-color: #2d3f52;
            --gradient-1: linear-gradient(135deg, #ff6b35 0%, #f7c548 100%);
            --gradient-2: linear-gradient(135deg, #00d4aa 0%, #00a8cc 100%);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .light {
            --bg-primary: #f5f0e8;
            --bg-secondary: #fff9f0;
            --bg-card: #ffffff;
            --bg-simulation: #fef8f0;
            --text-primary: #2c1810;
            --text-secondary: #6b5344;
            --border-color: #e0d5c8;
            --shadow: 0 8px 32px rgba(44, 24, 16, 0.12);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Source Sans 3', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .bg-pattern {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.03;
            background-image:
                radial-gradient(circle at 25% 25%, var(--accent-primary) 2px, transparent 2px),
                radial-gradient(circle at 75% 75%, var(--accent-tertiary) 1px, transparent 1px);
            background-size: 60px 60px;
            z-index: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            padding: 40px 20px;
            margin-bottom: 30px;
            position: relative;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 4px;
            background: var(--gradient-1);
            border-radius: 2px;
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: clamp(2rem, 5vw, 3.2rem);
            font-weight: 700;
            background: var(--gradient-1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            letter-spacing: -0.02em;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
            font-weight: 300;
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 30px;
            overflow-x: auto;
            padding: 5px;
            scrollbar-width: none;
        }

        .tabs::-webkit-scrollbar {
            display: none;
        }

        .tab-btn {
            padding: 14px 24px;
            border: 2px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-secondary);
            font-family: 'Source Sans 3', sans-serif;
            font-size: 0.95rem;
            font-weight: 500;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            position: relative;
            overflow: hidden;
        }

        .tab-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--gradient-1);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .tab-btn:hover {
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }

        .tab-btn.active {
            background: var(--gradient-1);
            border-color: transparent;
            color: #fff;
        }

        .lab-section {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .lab-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .lab-card {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 30px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .lab-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.6rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .lab-title .icon {
            width: 40px;
            height: 40px;
            background: var(--gradient-2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .description {
            color: var(--text-secondary);
            line-height: 1.7;
            margin-bottom: 20px;
            font-size: 1rem;
        }

        .simulation-area {
            background: var(--bg-simulation);
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
            min-height: 300px;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            margin: 0 auto;
            max-width: 100%;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .control-group {
            background: var(--bg-secondary);
            padding: 18px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .control-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 10px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: var(--border-color);
            appearance: none;
            outline: none;
            cursor: pointer;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--gradient-1);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.4);
            transition: transform 0.2s ease;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .value-display {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-secondary);
            font-size: 1.1rem;
            margin-top: 8px;
            font-weight: 500;
        }

        .formula-box {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-card) 100%);
            border-left: 4px solid var(--accent-primary);
            padding: 20px 25px;
            border-radius: 0 12px 12px 0;
            margin: 20px 0;
            overflow-x: auto;
        }

        .formula-box h4 {
            color: var(--accent-primary);
            margin-bottom: 15px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .formula-content {
            font-size: 1.1rem;
            line-height: 2;
        }

        .results-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .result-item {
            background: var(--bg-secondary);
            padding: 18px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid var(--border-color);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .result-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }

        .result-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .result-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--accent-tertiary);
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 10px;
            font-family: 'Source Sans 3', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--gradient-1);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 107, 53, 0.35);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }

        .btn-secondary:hover {
            border-color: var(--accent-tertiary);
            color: var(--accent-tertiary);
        }

        .action-btns {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .theory-section {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 25px;
            margin-top: 25px;
            border: 1px solid var(--border-color);
        }

        .theory-section h4 {
            font-family: 'Playfair Display', serif;
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--accent-secondary);
        }

        .theory-section ul {
            list-style: none;
            padding-left: 0;
        }

        .theory-section li {
            padding: 10px 0;
            padding-left: 25px;
            position: relative;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .theory-section li::before {
            content: '‚Üí';
            position: absolute;
            left: 0;
            color: var(--accent-primary);
            font-weight: bold;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .status-running {
            background: rgba(0, 212, 170, 0.15);
            color: var(--accent-tertiary);
        }

        .status-paused {
            background: rgba(247, 197, 72, 0.15);
            color: var(--accent-secondary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        .status-running .status-dot {
            background: var(--accent-tertiary);
        }

        .status-paused .status-dot {
            background: var(--accent-secondary);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            header {
                padding: 30px 15px;
            }

            .lab-card {
                padding: 20px;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            .formula-content {
                font-size: 0.95rem;
            }

            .tabs {
                justify-content: flex-start;
            }
        }

        .katex { font-size: 1.1em; }
        .katex-display { overflow-x: auto; overflow-y: hidden; padding: 10px 0; }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>

    <div class="container">
        <header>
            <h1>‚öõ Physics Lab Simulator</h1>
            <p class="subtitle">Interactive experiments with real-time calculations</p>
        </header>

        <div class="tabs">
            <button class="tab-btn active" data-tab="atwood">üîó Atwood Machine</button>
            <button class="tab-btn" data-tab="pendulum">üéØ Equilibrium</button>
            <button class="tab-btn" data-tab="incline">üìê Inclined Plane</button>
        </div>

        <!-- Atwood Machine Section -->
        <section id="atwood" class="lab-section active">
            <div class="lab-card">
                <h2 class="lab-title">
                    <span class="icon">‚öôÔ∏è</span>
                    Atwood Machine with Friction
                </h2>
                <p class="description">
                    An Atwood machine consists of two masses connected by an inextensible string over a frictionless pulley.
                    In this simulation, mass m‚ÇÅ rests on a horizontal surface with friction, while mass m‚ÇÇ hangs vertically.
                    Explore how friction affects the acceleration and tension in the system.
                </p>

                <div class="simulation-area">
                    <canvas id="atwoodCanvas" width="600" height="320"></canvas>
                </div>

                <div class="action-btns">
                    <button class="btn btn-primary" id="atwoodStart">‚ñ∂ Start</button>
                    <button class="btn btn-secondary" id="atwoodReset">‚Ü∫ Reset</button>
                    <span class="status-indicator status-paused" id="atwoodStatus">
                        <span class="status-dot"></span>
                        Paused
                    </span>
                </div>

                <div class="formula-box">
                    <h4>üìê Governing Equations</h4>
                    <div class="formula-content" id="atwoodFormulas"></div>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label>Mass on Table (m‚ÇÅ)</label>
                        <input type="range" id="m1" min="0.5" max="10" step="0.1" value="2">
                        <div class="value-display" id="m1Value">2.0 kg</div>
                    </div>
                    <div class="control-group">
                        <label>Hanging Mass (m‚ÇÇ)</label>
                        <input type="range" id="m2" min="0.5" max="10" step="0.1" value="4">
                        <div class="value-display" id="m2Value">4.0 kg</div>
                    </div>
                    <div class="control-group">
                        <label>Coefficient of Friction (Œº)</label>
                        <input type="range" id="mu" min="0" max="1" step="0.01" value="0.2">
                        <div class="value-display" id="muValue">0.20</div>
                    </div>
                    <div class="control-group">
                        <label>Gravity (g)</label>
                        <input type="range" id="g1" min="1" max="20" step="0.1" value="9.8">
                        <div class="value-display" id="g1Value">9.8 m/s¬≤</div>
                    </div>
                </div>

                <div class="results-panel">
                    <div class="result-item">
                        <div class="result-label">Acceleration</div>
                        <div class="result-value" id="atwoodAccel">0.00 m/s¬≤</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Tension</div>
                        <div class="result-value" id="atwoodTension">0.00 N</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Friction Force</div>
                        <div class="result-value" id="atwoodFriction">0.00 N</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Net Force</div>
                        <div class="result-value" id="atwoodNetForce">0.00 N</div>
                    </div>
                </div>

                <div class="theory-section">
                    <h4>üìñ Physical Principles</h4>
                    <ul>
                        <li>The string is assumed inextensible, so both masses have the same acceleration magnitude</li>
                        <li>Friction opposes the motion of m‚ÇÅ across the surface: f = ŒºN = Œºm‚ÇÅg</li>
                        <li>For m‚ÇÇ to descend: m‚ÇÇg must exceed the friction force plus m‚ÇÅ's inertia</li>
                        <li>System will not move if m‚ÇÇg ‚â§ Œºm‚ÇÅg (static equilibrium condition)</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Pendulum Equilibrium Section -->
        <section id="pendulum" class="lab-section">
            <div class="lab-card">
                <h2 class="lab-title">
                    <span class="icon">‚öñÔ∏è</span>
                    Static Equilibrium Analysis
                </h2>
                <p class="description">
                    A weight hangs from a string attached to a wall at angle Œ∏. A horizontal force F maintains equilibrium.
                    This classic statics problem demonstrates vector decomposition and the conditions for equilibrium
                    where the sum of all forces equals zero.
                </p>

                <div class="simulation-area">
                    <canvas id="pendulumCanvas" width="600" height="350"></canvas>
                </div>

                <div class="formula-box">
                    <h4>üìê Equilibrium Equations</h4>
                    <div class="formula-content" id="pendulumFormulas"></div>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label>Weight (W)</label>
                        <input type="range" id="weight" min="0.05" max="2" step="0.01" value="0.1">
                        <div class="value-display" id="weightValue">0.10 N</div>
                    </div>
                    <div class="control-group">
                        <label>String Angle (Œ∏)</label>
                        <input type="range" id="theta" min="10" max="80" step="1" value="60">
                        <div class="value-display" id="thetaValue">60¬∞</div>
                    </div>
                    <div class="control-group">
                        <label>String Length</label>
                        <input type="range" id="stringLen" min="20" max="80" step="1" value="50">
                        <div class="value-display" id="stringLenValue">50 cm</div>
                    </div>
                </div>

                <div class="results-panel">
                    <div class="result-item">
                        <div class="result-label">Tension (T)</div>
                        <div class="result-value" id="pendTension">0.00 N</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Horizontal Force (F)</div>
                        <div class="result-value" id="pendForce">0.00 N</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Horizontal Dist (d)</div>
                        <div class="result-value" id="pendDist">0.00 cm</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Vertical Height</div>
                        <div class="result-value" id="pendHeight">0.00 cm</div>
                    </div>
                </div>

                <div class="theory-section">
                    <h4>üìñ Physical Principles</h4>
                    <ul>
                        <li>At equilibrium: Œ£F‚Çì = 0 and Œ£F·µß = 0 (net force is zero)</li>
                        <li>Tension decomposes into horizontal (TsinŒ∏) and vertical (TcosŒ∏) components</li>
                        <li>The horizontal force F exactly balances the horizontal tension component</li>
                        <li>The vertical tension component supports the entire weight of the object</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Inclined Plane Section -->
        <section id="incline" class="lab-section">
            <div class="lab-card">
                <h2 class="lab-title">
                    <span class="icon">üìê</span>
                    Inclined Plane with Friction
                </h2>
                <p class="description">
                    A block rests on an inclined plane at angle Œ∏. Forces acting on the block include weight (W),
                    normal force (R), and friction (F). This simulation explores the conditions for sliding,
                    equilibrium, and the critical angle at which motion begins.
                </p>

                <div class="simulation-area">
                    <canvas id="inclineCanvas" width="600" height="350"></canvas>
                </div>

                <div class="action-btns">
                    <button class="btn btn-primary" id="inclineStart">‚ñ∂ Start</button>
                    <button class="btn btn-secondary" id="inclineReset">‚Ü∫ Reset</button>
                    <span class="status-indicator status-paused" id="inclineStatus">
                        <span class="status-dot"></span>
                        Paused
                    </span>
                </div>

                <div class="formula-box">
                    <h4>üìê Force Analysis</h4>
                    <div class="formula-content" id="inclineFormulas"></div>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label>Block Mass (m)</label>
                        <input type="range" id="blockMass" min="0.5" max="10" step="0.1" value="2">
                        <div class="value-display" id="blockMassValue">2.0 kg</div>
                    </div>
                    <div class="control-group">
                        <label>Incline Angle (Œ∏)</label>
                        <input type="range" id="inclineAngle" min="5" max="60" step="1" value="30">
                        <div class="value-display" id="inclineAngleValue">30¬∞</div>
                    </div>
                    <div class="control-group">
                        <label>Friction Coefficient (Œº)</label>
                        <input type="range" id="inclineMu" min="0" max="1.5" step="0.01" value="0.3">
                        <div class="value-display" id="inclineMuValue">0.30</div>
                    </div>
                    <div class="control-group">
                        <label>Gravity (g)</label>
                        <input type="range" id="g2" min="1" max="20" step="0.1" value="9.8">
                        <div class="value-display" id="g2Value">9.8 m/s¬≤</div>
                    </div>
                </div>

                <div class="results-panel">
                    <div class="result-item">
                        <div class="result-label">Weight (W)</div>
                        <div class="result-value" id="incWeight">0.00 N</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Normal Force (R)</div>
                        <div class="result-value" id="incNormal">0.00 N</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Friction (F)</div>
                        <div class="result-value" id="incFriction">0.00 N</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Acceleration</div>
                        <div class="result-value" id="incAccel">0.00 m/s¬≤</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Critical Angle</div>
                        <div class="result-value" id="incCritical">0.0¬∞</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Motion State</div>
                        <div class="result-value" id="incState">Static</div>
                    </div>
                </div>

                <div class="theory-section">
                    <h4>üìñ Physical Principles</h4>
                    <ul>
                        <li>Weight component parallel to incline: W‚à• = mg sin Œ∏</li>
                        <li>Weight component perpendicular to incline: W‚ä• = mg cos Œ∏</li>
                        <li>Normal force equals perpendicular weight: R = mg cos Œ∏</li>
                        <li>Maximum static friction: F_max = ŒºR = Œºmg cos Œ∏</li>
                        <li>Block slides when tan Œ∏ > Œº (critical angle Œ∏_c = arctan(Œº))</li>
                    </ul>
                </div>
            </div>
        </section>
    </div>

    <script>
        // Dark/Light mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
            document.documentElement.classList.add('light');
        }
        window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('light');
            } else {
                document.documentElement.classList.remove('light');
            }
        });

        // Tab navigation
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.lab-section').forEach(s => s.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(btn.dataset.tab).classList.add('active');
            });
        });

        // LaTeX rendering helper
        function renderLatex(elementId, latex) {
            const el = document.getElementById(elementId);
            el.innerHTML = '';
            latex.forEach(line => {
                const div = document.createElement('div');
                div.style.marginBottom = '10px';
                katex.render(line, div, { throwOnError: false, displayMode: true });
                el.appendChild(div);
            });
        }

        // ========== ATWOOD MACHINE SIMULATION ==========
        const atwoodCanvas = document.getElementById('atwoodCanvas');
        const atwoodCtx = atwoodCanvas.getContext('2d');
        let atwoodRunning = false;
        let atwoodAnimFrame = null;
        let atwoodY = 0;
        let atwoodVel = 0;

        function getAtwoodParams() {
            return {
                m1: parseFloat(document.getElementById('m1').value),
                m2: parseFloat(document.getElementById('m2').value),
                mu: parseFloat(document.getElementById('mu').value),
                g: parseFloat(document.getElementById('g1').value)
            };
        }

        function calculateAtwood() {
            const { m1, m2, mu, g } = getAtwoodParams();
            const friction = mu * m1 * g;
            const netDrivingForce = m2 * g - friction;
            let accel = 0;
            let tension = 0;

            if (netDrivingForce > 0) {
                accel = netDrivingForce / (m1 + m2);
                tension = m2 * (g - accel);
            } else {
                tension = m2 * g;
            }

            return { accel, tension, friction, netForce: netDrivingForce, canMove: netDrivingForce > 0 };
        }

        function updateAtwoodDisplay() {
            const { m1, m2, mu, g } = getAtwoodParams();
            const result = calculateAtwood();

            document.getElementById('m1Value').textContent = m1.toFixed(1) + ' kg';
            document.getElementById('m2Value').textContent = m2.toFixed(1) + ' kg';
            document.getElementById('muValue').textContent = mu.toFixed(2);
            document.getElementById('g1Value').textContent = g.toFixed(1) + ' m/s¬≤';

            document.getElementById('atwoodAccel').textContent = result.accel.toFixed(2) + ' m/s¬≤';
            document.getElementById('atwoodTension').textContent = result.tension.toFixed(2) + ' N';
            document.getElementById('atwoodFriction').textContent = result.friction.toFixed(2) + ' N';
            document.getElementById('atwoodNetForce').textContent = result.netForce.toFixed(2) + ' N';

            renderLatex('atwoodFormulas', [
                `\\text{For mass } m_2: \\quad m_2 g - T = m_2 a`,
                `\\text{For mass } m_1: \\quad T - f = m_1 a \\quad \\text{where } f = \\mu m_1 g`,
                `\\text{Solving: } \\quad a = \\frac{m_2 g - \\mu m_1 g}{m_1 + m_2} = \\frac{(${m2.toFixed(1)})(${g.toFixed(1)}) - (${mu.toFixed(2)})(${m1.toFixed(1)})(${g.toFixed(1)})}{${m1.toFixed(1)} + ${m2.toFixed(1)}}`,
                `a = ${result.accel.toFixed(3)} \\text{ m/s}^2`,
                `T = m_2(g - a) = ${result.tension.toFixed(2)} \\text{ N}`
            ]);

            drawAtwood();
        }

        function drawAtwood() {
            const ctx = atwoodCtx;
            const w = atwoodCanvas.width;
            const h = atwoodCanvas.height;
            const { m1, m2 } = getAtwoodParams();
            const result = calculateAtwood();

            ctx.clearRect(0, 0, w, h);

            // Table surface with texture
            ctx.fillStyle = '#3d5a80';
            ctx.fillRect(0, 140, 380, 15);
            ctx.strokeStyle = '#2c4a6e';
            ctx.lineWidth = 2;
            for (let i = 0; i < 380; i += 20) {
                ctx.beginPath();
                ctx.moveTo(i, 153);
                ctx.lineTo(i + 10, 145);
                ctx.stroke();
            }

            // Mass 1 on table
            const box1Size = 30 + m1 * 3;
            const box1X = 100 + atwoodY * 30;
            ctx.fillStyle = '#ff6b35';
            ctx.fillRect(box1X, 140 - box1Size, box1Size, box1Size);
            ctx.strokeStyle = '#cc5429';
            ctx.lineWidth = 2;
            ctx.strokeRect(box1X, 140 - box1Size, box1Size, box1Size);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px JetBrains Mono';
            ctx.textAlign = 'center';
            ctx.fillText(`${m1.toFixed(1)}kg`, box1X + box1Size/2, 140 - box1Size/2 + 5);

            // Pulley
            ctx.beginPath();
            ctx.arc(400, 130, 20, 0, Math.PI * 2);
            ctx.fillStyle = '#4a5568';
            ctx.fill();
            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(400, 130, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#718096';
            ctx.fill();

            // String
            ctx.strokeStyle = '#f7c548';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(box1X + box1Size, 140 - box1Size/2);
            ctx.lineTo(400, 140 - box1Size/2);
            ctx.lineTo(400, 110);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(400, 130, 20, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(420, 130);
            ctx.lineTo(420, 160 + atwoodY * 30);
            ctx.stroke();

            // Mass 2 hanging
            const box2Size = 30 + m2 * 3;
            ctx.fillStyle = '#00d4aa';
            ctx.fillRect(420 - box2Size/2, 160 + atwoodY * 30, box2Size, box2Size);
            ctx.strokeStyle = '#00a88a';
            ctx.lineWidth = 2;
            ctx.strokeRect(420 - box2Size/2, 160 + atwoodY * 30, box2Size, box2Size);
            ctx.fillStyle = '#fff';
            ctx.fillText(`${m2.toFixed(1)}kg`, 420, 160 + atwoodY * 30 + box2Size/2 + 5);

            // Force arrows
            if (result.canMove) {
                // Tension arrow on m1
                drawArrow(ctx, box1X + box1Size + 10, 140 - box1Size/2, box1X + box1Size + 50, 140 - box1Size/2, '#f7c548', 'T');
                // Friction arrow on m1
                drawArrow(ctx, box1X - 10, 140 - box1Size/2, box1X - 40, 140 - box1Size/2, '#ff4757', 'f');
            }

            // Status text
            ctx.fillStyle = result.canMove ? '#00d4aa' : '#f7c548';
            ctx.font = '14px Source Sans 3';
            ctx.textAlign = 'left';
            ctx.fillText(result.canMove ? '‚óè System accelerating' : '‚óè Static equilibrium', 20, 25);
        }

        function drawArrow(ctx, x1, y1, x2, y2, color, label) {
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const len = Math.sqrt((x2-x1)**2 + (y2-y1)**2);

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 10 * Math.cos(angle - 0.4), y2 - 10 * Math.sin(angle - 0.4));
            ctx.lineTo(x2 - 10 * Math.cos(angle + 0.4), y2 - 10 * Math.sin(angle + 0.4));
            ctx.closePath();
            ctx.fill();

            if (label) {
                ctx.font = 'bold 12px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText(label, (x1 + x2) / 2, y1 - 10);
            }
        }

        function animateAtwood() {
            if (!atwoodRunning) return;
            const result = calculateAtwood();

            if (result.canMove && atwoodY < 3) {
                atwoodVel += result.accel * 0.016;
                atwoodY += atwoodVel * 0.05;
                drawAtwood();
                atwoodAnimFrame = requestAnimationFrame(animateAtwood);
            } else {
                atwoodRunning = false;
                updateAtwoodStatus(false);
            }
        }

        function updateAtwoodStatus(running) {
            const status = document.getElementById('atwoodStatus');
            if (running) {
                status.className = 'status-indicator status-running';
                status.innerHTML = '<span class="status-dot"></span>Running';
            } else {
                status.className = 'status-indicator status-paused';
                status.innerHTML = '<span class="status-dot"></span>Paused';
            }
        }

        document.getElementById('atwoodStart').addEventListener('click', () => {
            if (!atwoodRunning) {
                atwoodRunning = true;
                updateAtwoodStatus(true);
                animateAtwood();
            } else {
                atwoodRunning = false;
                updateAtwoodStatus(false);
            }
        });

        document.getElementById('atwoodReset').addEventListener('click', () => {
            atwoodRunning = false;
            atwoodY = 0;
            atwoodVel = 0;
            updateAtwoodStatus(false);
            drawAtwood();
        });

        ['m1', 'm2', 'mu', 'g1'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                atwoodY = 0;
                atwoodVel = 0;
                atwoodRunning = false;
                updateAtwoodStatus(false);
                updateAtwoodDisplay();
            });
        });

        // ========== PENDULUM EQUILIBRIUM SIMULATION ==========
        const pendulumCanvas = document.getElementById('pendulumCanvas');
        const pendulumCtx = pendulumCanvas.getContext('2d');

        function getPendulumParams() {
            return {
                weight: parseFloat(document.getElementById('weight').value),
                theta: parseFloat(document.getElementById('theta').value),
                stringLen: parseFloat(document.getElementById('stringLen').value)
            };
        }

        function calculatePendulum() {
            const { weight, theta, stringLen } = getPendulumParams();
            const thetaRad = theta * Math.PI / 180;
            const tension = weight / Math.cos(thetaRad);
            const force = tension * Math.sin(thetaRad);
            const horizDist = stringLen * Math.sin(thetaRad);
            const vertHeight = stringLen * Math.cos(thetaRad);
            return { tension, force, horizDist, vertHeight };
        }

        function updatePendulumDisplay() {
            const { weight, theta, stringLen } = getPendulumParams();
            const result = calculatePendulum();

            document.getElementById('weightValue').textContent = weight.toFixed(2) + ' N';
            document.getElementById('thetaValue').textContent = theta + '¬∞';
            document.getElementById('stringLenValue').textContent = stringLen + ' cm';

            document.getElementById('pendTension').textContent = result.tension.toFixed(3) + ' N';
            document.getElementById('pendForce').textContent = result.force.toFixed(3) + ' N';
            document.getElementById('pendDist').textContent = result.horizDist.toFixed(1) + ' cm';
            document.getElementById('pendHeight').textContent = result.vertHeight.toFixed(1) + ' cm';

            renderLatex('pendulumFormulas', [
                `\\text{Equilibrium conditions: } \\sum F_x = 0, \\quad \\sum F_y = 0`,
                `\\text{Vertical: } T \\cos\\theta = W \\quad \\Rightarrow \\quad T = \\frac{W}{\\cos\\theta} = \\frac{${weight.toFixed(2)}}{\\cos(${theta}¬∞)}`,
                `T = ${result.tension.toFixed(4)} \\text{ N}`,
                `\\text{Horizontal: } F = T \\sin\\theta = ${result.tension.toFixed(4)} \\times \\sin(${theta}¬∞) = ${result.force.toFixed(4)} \\text{ N}`,
                `d = L \\sin\\theta = ${stringLen} \\times \\sin(${theta}¬∞) = ${result.horizDist.toFixed(2)} \\text{ cm}`
            ]);

            drawPendulum();
        }

        function drawPendulum() {
            const ctx = pendulumCtx;
            const w = pendulumCanvas.width;
            const h = pendulumCanvas.height;
            const { weight, theta, stringLen } = getPendulumParams();
            const result = calculatePendulum();

            ctx.clearRect(0, 0, w, h);

            const anchorX = 150;
            const anchorY = 50;
            const scale = 2.5;
            const thetaRad = theta * Math.PI / 180;
            const bobX = anchorX + stringLen * scale * Math.sin(thetaRad);
            const bobY = anchorY + stringLen * scale * Math.cos(thetaRad);

            // Wall with hatching
            ctx.fillStyle = '#4a5568';
            ctx.fillRect(100, 30, 50, 20);
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(105 + i * 10, 30);
                ctx.lineTo(115 + i * 10, 50);
                ctx.strokeStyle = '#2d3748';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // String
            ctx.beginPath();
            ctx.moveTo(anchorX, anchorY);
            ctx.lineTo(bobX, bobY);
            ctx.strokeStyle = '#f7c548';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Angle arc
            ctx.beginPath();
            ctx.arc(anchorX, anchorY, 40, Math.PI/2 - thetaRad, Math.PI/2);
            ctx.strokeStyle = '#00d4aa';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#00d4aa';
            ctx.font = '14px JetBrains Mono';
            ctx.fillText(`${theta}¬∞`, anchorX - 35, anchorY + 55);

            // Dashed vertical line
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(anchorX, anchorY);
            ctx.lineTo(anchorX, bobY + 30);
            ctx.strokeStyle = '#718096';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);

            // Horizontal distance indicator
            ctx.beginPath();
            ctx.moveTo(anchorX, bobY);
            ctx.lineTo(bobX, bobY);
            ctx.strokeStyle = '#00d4aa';
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#00d4aa';
            ctx.font = '12px JetBrains Mono';
            ctx.textAlign = 'center';
            ctx.fillText(`d = ${result.horizDist.toFixed(1)}cm`, (anchorX + bobX) / 2, bobY - 8);

            // Bob (weight)
            ctx.beginPath();
            ctx.arc(bobX, bobY, 15, 0, Math.PI * 2);
            ctx.fillStyle = '#ff6b35';
            ctx.fill();
            ctx.strokeStyle = '#cc5429';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Force arrows
            const arrowScale = 150;

            // Weight arrow (down)
            drawArrow(ctx, bobX, bobY + 15, bobX, bobY + 15 + weight * arrowScale, '#e74c3c', 'W');

            // Tension arrow (along string toward anchor)
            const tensionLen = result.tension * arrowScale * 0.8;
            const tx = bobX - tensionLen * Math.sin(thetaRad);
            const ty = bobY - tensionLen * Math.cos(thetaRad);
            drawArrow(ctx, bobX, bobY, tx, ty, '#f7c548', 'T');

            // Horizontal force arrow
            const forceLen = result.force * arrowScale;
            drawArrow(ctx, bobX + 15, bobY, bobX + 15 + forceLen, bobY, '#00d4aa', 'F');

            // Length label on string
            ctx.save();
            ctx.translate((anchorX + bobX) / 2, (anchorY + bobY) / 2);
            ctx.rotate(thetaRad);
            ctx.fillStyle = '#f7c548';
            ctx.font = '12px JetBrains Mono';
            ctx.textAlign = 'center';
            ctx.fillText(`${stringLen}cm`, 0, -10);
            ctx.restore();

            // Legend
            ctx.textAlign = 'left';
            ctx.font = '13px Source Sans 3';
            ctx.fillStyle = '#e74c3c';
            ctx.fillText('‚óè Weight (W)', 420, 50);
            ctx.fillStyle = '#f7c548';
            ctx.fillText('‚óè Tension (T)', 420, 75);
            ctx.fillStyle = '#00d4aa';
            ctx.fillText('‚óè Horizontal Force (F)', 420, 100);
        }

        ['weight', 'theta', 'stringLen'].forEach(id => {
            document.getElementById(id).addEventListener('input', updatePendulumDisplay);
        });

        // ========== INCLINED PLANE SIMULATION ==========
        const inclineCanvas = document.getElementById('inclineCanvas');
        const inclineCtx = inclineCanvas.getContext('2d');
        let inclineRunning = false;
        let inclinePos = 0;
        let inclineVel = 0;

        function getInclineParams() {
            return {
                mass: parseFloat(document.getElementById('blockMass').value),
                angle: parseFloat(document.getElementById('inclineAngle').value),
                mu: parseFloat(document.getElementById('inclineMu').value),
                g: parseFloat(document.getElementById('g2').value)
            };
        }

        function calculateIncline() {
            const { mass, angle, mu, g } = getInclineParams();
            const angleRad = angle * Math.PI / 180;
            const weight = mass * g;
            const normal = weight * Math.cos(angleRad);
            const parallelForce = weight * Math.sin(angleRad);
            const maxFriction = mu * normal;
            const criticalAngle = Math.atan(mu) * 180 / Math.PI;

            let accel = 0;
            let friction = parallelForce;
            let isSliding = parallelForce > maxFriction;

            if (isSliding) {
                friction = maxFriction;
                accel = (parallelForce - maxFriction) / mass;
            }

            return { weight, normal, friction, accel, criticalAngle, isSliding, parallelForce };
        }

        function updateInclineDisplay() {
            const { mass, angle, mu, g } = getInclineParams();
            const result = calculateIncline();

            document.getElementById('blockMassValue').textContent = mass.toFixed(1) + ' kg';
            document.getElementById('inclineAngleValue').textContent = angle + '¬∞';
            document.getElementById('inclineMuValue').textContent = mu.toFixed(2);
            document.getElementById('g2Value').textContent = g.toFixed(1) + ' m/s¬≤';

            document.getElementById('incWeight').textContent = result.weight.toFixed(2) + ' N';
            document.getElementById('incNormal').textContent = result.normal.toFixed(2) + ' N';
            document.getElementById('incFriction').textContent = result.friction.toFixed(2) + ' N';
            document.getElementById('incAccel').textContent = result.accel.toFixed(2) + ' m/s¬≤';
            document.getElementById('incCritical').textContent = result.criticalAngle.toFixed(1) + '¬∞';
            document.getElementById('incState').textContent = result.isSliding ? 'Sliding ‚Üì' : 'Static';
            document.getElementById('incState').style.color = result.isSliding ? '#ff6b35' : '#00d4aa';

            renderLatex('inclineFormulas', [
                `\\text{Weight components: } W_\\parallel = mg\\sin\\theta, \\quad W_\\perp = mg\\cos\\theta`,
                `W = mg = ${mass.toFixed(1)} \\times ${g.toFixed(1)} = ${result.weight.toFixed(2)} \\text{ N}`,
                `\\text{Normal force: } R = W_\\perp = mg\\cos(${angle}¬∞) = ${result.normal.toFixed(2)} \\text{ N}`,
                `\\text{Max friction: } F_{max} = \\mu R = ${mu.toFixed(2)} \\times ${result.normal.toFixed(2)} = ${(mu * result.normal).toFixed(2)} \\text{ N}`,
                `\\text{Component down slope: } W_\\parallel = ${result.parallelForce.toFixed(2)} \\text{ N}`,
                result.isSliding ?
                    `a = \\frac{W_\\parallel - F}{m} = g(\\sin\\theta - \\mu\\cos\\theta) = ${result.accel.toFixed(2)} \\text{ m/s}^2` :
                    `\\text{Static equilibrium: } W_\\parallel \\leq F_{max}`,
                `\\text{Critical angle: } \\theta_c = \\arctan(\\mu) = \\arctan(${mu.toFixed(2)}) = ${result.criticalAngle.toFixed(1)}¬∞`
            ]);

            drawIncline();
        }

        function drawIncline() {
            const ctx = inclineCtx;
            const w = inclineCanvas.width;
            const h = inclineCanvas.height;
            const { mass, angle, mu } = getInclineParams();
            const result = calculateIncline();
            const angleRad = angle * Math.PI / 180;

            ctx.clearRect(0, 0, w, h);

            // Draw inclined plane
            ctx.save();
            ctx.translate(100, 300);

            // Ground
            ctx.fillStyle = '#4a5568';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(400, 0);
            ctx.lineTo(400, 20);
            ctx.lineTo(0, 20);
            ctx.fill();

            // Incline surface
            const inclineLen = 350;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(inclineLen * Math.cos(angleRad), -inclineLen * Math.sin(angleRad));
            ctx.lineTo(inclineLen * Math.cos(angleRad), 0);
            ctx.closePath();
            ctx.fillStyle = '#3d5a80';
            ctx.fill();
            ctx.strokeStyle = '#2c4a6e';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Angle arc
            ctx.beginPath();
            ctx.arc(0, 0, 50, -angleRad, 0);
            ctx.strokeStyle = '#00d4aa';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#00d4aa';
            ctx.font = '14px JetBrains Mono';
            ctx.fillText(`Œ∏=${angle}¬∞`, 55, -10);

            // Block on incline
            const blockSize = 40;
            const blockDist = 120 + inclinePos * 50;
            const blockX = blockDist * Math.cos(angleRad);
            const blockY = -blockDist * Math.sin(angleRad);

            ctx.save();
            ctx.translate(blockX, blockY);
            ctx.rotate(-angleRad);

            // Block
            ctx.fillStyle = '#ff6b35';
            ctx.fillRect(-blockSize/2, -blockSize, blockSize, blockSize);
            ctx.strokeStyle = '#cc5429';
            ctx.lineWidth = 2;
            ctx.strokeRect(-blockSize/2, -blockSize, blockSize, blockSize);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px JetBrains Mono';
            ctx.textAlign = 'center';
            ctx.fillText(`${mass.toFixed(1)}kg`, 0, -blockSize/2 + 4);

            // Force arrows (in rotated frame)
            const forceScale = 2;

            // Normal force (perpendicular to surface, pointing up in rotated frame)
            drawArrow(ctx, 0, -blockSize, 0, -blockSize - result.normal * forceScale, '#3498db', 'R');

            // Friction (along surface, up the slope in rotated frame)
            if (result.friction > 0) {
                drawArrow(ctx, 0, -blockSize/2, -result.friction * forceScale, -blockSize/2, '#e74c3c', 'F');
            }

            ctx.restore();

            // Weight arrow (always points straight down in world frame)
            const weightArrowX = blockX;
            const weightArrowY = blockY - blockSize/2;
            ctx.save();
            ctx.translate(100, 300);
            drawArrow(ctx, weightArrowX, weightArrowY, weightArrowX, weightArrowY + result.weight * forceScale, '#9b59b6', 'W');
            ctx.restore();

            ctx.restore();

            // Status indicator
            ctx.fillStyle = result.isSliding ? '#ff6b35' : '#00d4aa';
            ctx.font = '14px Source Sans 3';
            ctx.textAlign = 'left';
            ctx.fillText(result.isSliding ? '‚óè Block sliding down' : '‚óè Block in equilibrium', 20, 25);

            // Critical angle comparison
            ctx.fillStyle = '#8899a6';
            ctx.fillText(`Current Œ∏ (${angle}¬∞) ${angle > result.criticalAngle ? '>' : '‚â§'} Critical Œ∏ (${result.criticalAngle.toFixed(1)}¬∞)`, 20, 45);

            // Legend
            ctx.textAlign = 'left';
            ctx.font = '13px Source Sans 3';
            ctx.fillStyle = '#9b59b6';
            ctx.fillText('‚óè Weight (W)', 450, 50);
            ctx.fillStyle = '#3498db';
            ctx.fillText('‚óè Normal (R)', 450, 75);
            ctx.fillStyle = '#e74c3c';
            ctx.fillText('‚óè Friction (F)', 450, 100);
        }

        function animateIncline() {
            if (!inclineRunning) return;
            const result = calculateIncline();

            if (result.isSliding && inclinePos < 4) {
                inclineVel += result.accel * 0.016;
                inclinePos += inclineVel * 0.03;
                drawIncline();
                requestAnimationFrame(animateIncline);
            } else {
                inclineRunning = false;
                updateInclineStatus(false);
            }
        }

        function updateInclineStatus(running) {
            const status = document.getElementById('inclineStatus');
            if (running) {
                status.className = 'status-indicator status-running';
                status.innerHTML = '<span class="status-dot"></span>Running';
            } else {
                status.className = 'status-indicator status-paused';
                status.innerHTML = '<span class="status-dot"></span>Paused';
            }
        }

        document.getElementById('inclineStart').addEventListener('click', () => {
            if (!inclineRunning) {
                inclineRunning = true;
                updateInclineStatus(true);
                animateIncline();
            } else {
                inclineRunning = false;
                updateInclineStatus(false);
            }
        });

        document.getElementById('inclineReset').addEventListener('click', () => {
            inclineRunning = false;
            inclinePos = 0;
            inclineVel = 0;
            updateInclineStatus(false);
            drawIncline();
        });

        ['blockMass', 'inclineAngle', 'inclineMu', 'g2'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                inclinePos = 0;
                inclineVel = 0;
                inclineRunning = false;
                updateInclineStatus(false);
                updateInclineDisplay();
            });
        });

        // Initialize all simulations
        updateAtwoodDisplay();
        updatePendulumDisplay();
        updateInclineDisplay();
    </script>
</body>
</html>

